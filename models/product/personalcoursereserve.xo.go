// Package tpl contains the types for schema 'saas'.
package product

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	"go.uber.org/zap"
	"j7go/components"
	"j7go/utils"
)

// PersonalCourseReserve represents a row from 'saas.personal_course_reserve'.
type PersonalCourseReserve struct {
	ID                    uint   `json:"id"`                      // id
	BrandID               uint   `json:"brand_id"`                // brand_id
	ShopID                uint   `json:"shop_id"`                 // shop_id
	CoachID               uint   `json:"coach_id"`                // coach_id
	CoachName             string `json:"coach_name"`              // coach_name
	ScheduleID            uint   `json:"schedule_id"`             // schedule_id
	MemberID              uint   `json:"member_id"`               // member_id
	CardType              int8   `json:"card_type"`               // card_type
	CardID                uint   `json:"card_id"`                 // card_id
	CourseID              uint   `json:"course_id"`               // course_id
	CoursePackageID       uint   `json:"course_package_id"`       // course_package_id
	CourseName            string `json:"course_name"`             // course_name
	ConsumeName           string `json:"consume_name"`            // consume_name
	ConsumeType           int8   `json:"consume_type"`            // consume_type
	LimitNum              uint   `json:"limit_num"`               // limit_num
	ConsumeUnit           uint   `json:"consume_unit"`            // consume_unit
	ConsumeUnitNum        uint   `json:"consume_unit_num"`        // consume_unit_num
	CurrentReservationNum uint   `json:"current_reservation_num"` // current_reservation_num
	IsGroupBuy            int8   `json:"is_group_buy"`            // is_group_buy
	IsWaiting             int8   `json:"is_waiting"`              // is_waiting
	ReserveStatus         int8   `json:"reserve_status"`          // reserve_status
	ReserveMethod         int8   `json:"reserve_method"`          // reserve_method
	IsCheckin             int8   `json:"is_checkin"`              // is_checkin
	CheckinMethod         int8   `json:"checkin_method"`          // checkin_method
	ReserveID             uint   `json:"reserve_id"`              // reserve_id
	CheckinID             uint   `json:"checkin_id"`              // checkin_id
	CheckinTime           uint   `json:"checkin_time"`            // checkin_time
	StartDate             uint   `json:"start_date"`              // start_date
	StartTime             uint   `json:"start_time"`              // start_time
	EndTime               uint   `json:"end_time"`                // end_time
	IsDel                 int8   `json:"is_del"`                  // is_del
	CreatedTime           uint   `json:"created_time"`            // created_time
	UpdatedTime           uint   `json:"updated_time"`            // updated_time

	// xo fields
	_exists, _deleted bool
}

// Exists determines if the PersonalCourseReserve exists in the database.
func (pcr *PersonalCourseReserve) Exists() bool { //personal_course_reserve
	return pcr._exists
}

// Deleted provides information if the PersonalCourseReserve has been deleted from the database.
func (pcr *PersonalCourseReserve) Deleted() bool {
	return pcr._deleted
}

// Get table name
func GetPersonalCourseReserveTableName(key ...interface{}) (string, error) {
	tableName, err := components.M.GetTable("saas", "personal_course_reserve", key...)
	if err != nil {
		return "", err
	}
	return tableName, nil
}

// Insert inserts the PersonalCourseReserve to the database.
func (pcr *PersonalCourseReserve) Insert(ctx context.Context, key ...interface{}) error {
	var err error
	var dbConn *sql.DB
	var res sql.Result
	// if already exist, bail
	if pcr._exists {
		return errors.New("insert failed: already exists")
	}

	tx, err := components.M.GetConnFromCtx(ctx)
	if err != nil {
		dbConn, err = components.M.GetMasterConn()
		if err != nil {
			return err
		}
	}

	tableName, err := GetPersonalCourseReserveTableName(key...)
	if err != nil {
		return err
	}

	// sql insert query, primary key provided by autoincrement
	sqlstr := `INSERT INTO ` + tableName +
		` (` +
		`brand_id, shop_id, coach_id, coach_name, schedule_id, member_id, card_type, card_id, course_id, course_package_id, course_name, consume_name, consume_type, limit_num, consume_unit, consume_unit_num, current_reservation_num, is_group_buy, is_waiting, reserve_status, reserve_method, is_checkin, checkin_method, reserve_id, checkin_id, checkin_time, start_date, start_time, end_time, is_del, created_time, updated_time` +
		`) VALUES (` +
		`?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?` +
		`)`

	// run query
	utils.GetTraceLog(ctx).Debug("DB", zap.String("SQL", fmt.Sprint(sqlstr, pcr.BrandID, pcr.ShopID, pcr.CoachID, pcr.CoachName, pcr.ScheduleID, pcr.MemberID, pcr.CardType, pcr.CardID, pcr.CourseID, pcr.CoursePackageID, pcr.CourseName, pcr.ConsumeName, pcr.ConsumeType, pcr.LimitNum, pcr.ConsumeUnit, pcr.ConsumeUnitNum, pcr.CurrentReservationNum, pcr.IsGroupBuy, pcr.IsWaiting, pcr.ReserveStatus, pcr.ReserveMethod, pcr.IsCheckin, pcr.CheckinMethod, pcr.ReserveID, pcr.CheckinID, pcr.CheckinTime, pcr.StartDate, pcr.StartTime, pcr.EndTime, pcr.IsDel, pcr.CreatedTime, pcr.UpdatedTime)))
	if err != nil {
		return err
	}
	if tx != nil {
		res, err = tx.Exec(sqlstr, pcr.BrandID, pcr.ShopID, pcr.CoachID, pcr.CoachName, pcr.ScheduleID, pcr.MemberID, pcr.CardType, pcr.CardID, pcr.CourseID, pcr.CoursePackageID, pcr.CourseName, pcr.ConsumeName, pcr.ConsumeType, pcr.LimitNum, pcr.ConsumeUnit, pcr.ConsumeUnitNum, pcr.CurrentReservationNum, pcr.IsGroupBuy, pcr.IsWaiting, pcr.ReserveStatus, pcr.ReserveMethod, pcr.IsCheckin, pcr.CheckinMethod, pcr.ReserveID, pcr.CheckinID, pcr.CheckinTime, pcr.StartDate, pcr.StartTime, pcr.EndTime, pcr.IsDel, pcr.CreatedTime, pcr.UpdatedTime)
	} else {
		res, err = dbConn.Exec(sqlstr, pcr.BrandID, pcr.ShopID, pcr.CoachID, pcr.CoachName, pcr.ScheduleID, pcr.MemberID, pcr.CardType, pcr.CardID, pcr.CourseID, pcr.CoursePackageID, pcr.CourseName, pcr.ConsumeName, pcr.ConsumeType, pcr.LimitNum, pcr.ConsumeUnit, pcr.ConsumeUnitNum, pcr.CurrentReservationNum, pcr.IsGroupBuy, pcr.IsWaiting, pcr.ReserveStatus, pcr.ReserveMethod, pcr.IsCheckin, pcr.CheckinMethod, pcr.ReserveID, pcr.CheckinID, pcr.CheckinTime, pcr.StartDate, pcr.StartTime, pcr.EndTime, pcr.IsDel, pcr.CreatedTime, pcr.UpdatedTime)
	}

	if err != nil {
		return err
	}

	// retrieve id
	id, err := res.LastInsertId()
	if err != nil {
		return err
	}

	// set primary key and existence
	pcr.ID = uint(id)
	pcr._exists = true

	return nil
}

// Update updates the PersonalCourseReserve in the database.
func (pcr *PersonalCourseReserve) Update(ctx context.Context, key ...interface{}) error {
	var err error
	var dbConn *sql.DB

	// if deleted, bail
	if pcr._deleted {
		return errors.New("update failed: marked for deletion")
	}

	tx, err := components.M.GetConnFromCtx(ctx)
	if err != nil {
		dbConn, err = components.M.GetMasterConn()
		if err != nil {
			return err
		}
	}

	tableName, err := GetPersonalCourseReserveTableName(key...)
	if err != nil {
		return err
	}

	// sql query
	sqlstr := `UPDATE ` + tableName + ` SET ` +
		`brand_id = ?, shop_id = ?, coach_id = ?, coach_name = ?, schedule_id = ?, member_id = ?, card_type = ?, card_id = ?, course_id = ?, course_package_id = ?, course_name = ?, consume_name = ?, consume_type = ?, limit_num = ?, consume_unit = ?, consume_unit_num = ?, current_reservation_num = ?, is_group_buy = ?, is_waiting = ?, reserve_status = ?, reserve_method = ?, is_checkin = ?, checkin_method = ?, reserve_id = ?, checkin_id = ?, checkin_time = ?, start_date = ?, start_time = ?, end_time = ?, is_del = ?, created_time = ?, updated_time = ?` +
		` WHERE id = ?`

	// run query
	utils.GetTraceLog(ctx).Debug("DB", zap.String("SQL", fmt.Sprint(sqlstr, pcr.BrandID, pcr.ShopID, pcr.CoachID, pcr.CoachName, pcr.ScheduleID, pcr.MemberID, pcr.CardType, pcr.CardID, pcr.CourseID, pcr.CoursePackageID, pcr.CourseName, pcr.ConsumeName, pcr.ConsumeType, pcr.LimitNum, pcr.ConsumeUnit, pcr.ConsumeUnitNum, pcr.CurrentReservationNum, pcr.IsGroupBuy, pcr.IsWaiting, pcr.ReserveStatus, pcr.ReserveMethod, pcr.IsCheckin, pcr.CheckinMethod, pcr.ReserveID, pcr.CheckinID, pcr.CheckinTime, pcr.StartDate, pcr.StartTime, pcr.EndTime, pcr.IsDel, pcr.CreatedTime, pcr.UpdatedTime, pcr.ID)))
	if tx != nil {
		_, err = tx.Exec(sqlstr, pcr.BrandID, pcr.ShopID, pcr.CoachID, pcr.CoachName, pcr.ScheduleID, pcr.MemberID, pcr.CardType, pcr.CardID, pcr.CourseID, pcr.CoursePackageID, pcr.CourseName, pcr.ConsumeName, pcr.ConsumeType, pcr.LimitNum, pcr.ConsumeUnit, pcr.ConsumeUnitNum, pcr.CurrentReservationNum, pcr.IsGroupBuy, pcr.IsWaiting, pcr.ReserveStatus, pcr.ReserveMethod, pcr.IsCheckin, pcr.CheckinMethod, pcr.ReserveID, pcr.CheckinID, pcr.CheckinTime, pcr.StartDate, pcr.StartTime, pcr.EndTime, pcr.IsDel, pcr.CreatedTime, pcr.UpdatedTime, pcr.ID)
	} else {
		_, err = dbConn.Exec(sqlstr, pcr.BrandID, pcr.ShopID, pcr.CoachID, pcr.CoachName, pcr.ScheduleID, pcr.MemberID, pcr.CardType, pcr.CardID, pcr.CourseID, pcr.CoursePackageID, pcr.CourseName, pcr.ConsumeName, pcr.ConsumeType, pcr.LimitNum, pcr.ConsumeUnit, pcr.ConsumeUnitNum, pcr.CurrentReservationNum, pcr.IsGroupBuy, pcr.IsWaiting, pcr.ReserveStatus, pcr.ReserveMethod, pcr.IsCheckin, pcr.CheckinMethod, pcr.ReserveID, pcr.CheckinID, pcr.CheckinTime, pcr.StartDate, pcr.StartTime, pcr.EndTime, pcr.IsDel, pcr.CreatedTime, pcr.UpdatedTime, pcr.ID)
	}
	return err
}

// Save saves the PersonalCourseReserve to the database.
func (pcr *PersonalCourseReserve) Save(ctx context.Context) error {
	if pcr.Exists() {
		return pcr.Update(ctx)
	}

	return pcr.Insert(ctx)
}

// Delete deletes the PersonalCourseReserve from the database.
func (pcr *PersonalCourseReserve) Delete(ctx context.Context, key ...interface{}) error {
	var err error
	var dbConn *sql.DB

	// if deleted, bail
	if pcr._deleted {
		return nil
	}

	tx, err := components.M.GetConnFromCtx(ctx)
	if err != nil {
		dbConn, err = components.M.GetMasterConn()
		if err != nil {
			return err
		}
	}

	tableName, err := GetPersonalCourseReserveTableName(key...)
	if err != nil {
		return err
	}
	//1

	// sql query with composite primary key
	sqlstr := `UPDATE ` + tableName + ` SET is_del = 1 WHERE id = ?`

	// run query
	utils.GetTraceLog(ctx).Debug("DB", zap.String("SQL", fmt.Sprint(sqlstr, pcr.ID)))
	if tx != nil {
		_, err = tx.Exec(sqlstr, pcr.ID)
	} else {
		_, err = dbConn.Exec(sqlstr, pcr.ID)
	}

	if err != nil {
		return err
	}

	// set deleted
	pcr._deleted = true

	return nil
}

// PersonalCourseReserveByID retrieves a row from 'saas.personal_course_reserve' as a PersonalCourseReserve.
//
// Generated from index 'personal_course_reserve_id_pkey'.
func PersonalCourseReserveByID(ctx context.Context, id uint, key ...interface{}) (*PersonalCourseReserve, error) {
	var err error
	var dbConn *sql.DB

	tableName, err := GetPersonalCourseReserveTableName(key...)
	if err != nil {
		return nil, err
	}

	// sql query
	sqlstr := `SELECT ` +
		`id, brand_id, shop_id, coach_id, coach_name, schedule_id, member_id, card_type, card_id, course_id, course_package_id, course_name, consume_name, consume_type, limit_num, consume_unit, consume_unit_num, current_reservation_num, is_group_buy, is_waiting, reserve_status, reserve_method, is_checkin, checkin_method, reserve_id, checkin_id, checkin_time, start_date, start_time, end_time, is_del, created_time, updated_time ` +
		`FROM ` + tableName +
		` WHERE id = ?`

	// run query
	utils.GetTraceLog(ctx).Debug("DB", zap.String("SQL", fmt.Sprint(sqlstr, id)))

	tx, err := components.M.GetConnFromCtx(ctx)
	if err != nil {
		dbConn, err = components.M.GetSlaveConn()
		if err != nil {
			return nil, err
		}
	}
	pcr := PersonalCourseReserve{
		_exists: true,
	}

	if tx != nil {
		err = tx.QueryRow(sqlstr, id).Scan(&pcr.ID, &pcr.BrandID, &pcr.ShopID, &pcr.CoachID, &pcr.CoachName, &pcr.ScheduleID, &pcr.MemberID, &pcr.CardType, &pcr.CardID, &pcr.CourseID, &pcr.CoursePackageID, &pcr.CourseName, &pcr.ConsumeName, &pcr.ConsumeType, &pcr.LimitNum, &pcr.ConsumeUnit, &pcr.ConsumeUnitNum, &pcr.CurrentReservationNum, &pcr.IsGroupBuy, &pcr.IsWaiting, &pcr.ReserveStatus, &pcr.ReserveMethod, &pcr.IsCheckin, &pcr.CheckinMethod, &pcr.ReserveID, &pcr.CheckinID, &pcr.CheckinTime, &pcr.StartDate, &pcr.StartTime, &pcr.EndTime, &pcr.IsDel, &pcr.CreatedTime, &pcr.UpdatedTime)
		if err != nil {
			return nil, err
		}
	} else {
		err = dbConn.QueryRow(sqlstr, id).Scan(&pcr.ID, &pcr.BrandID, &pcr.ShopID, &pcr.CoachID, &pcr.CoachName, &pcr.ScheduleID, &pcr.MemberID, &pcr.CardType, &pcr.CardID, &pcr.CourseID, &pcr.CoursePackageID, &pcr.CourseName, &pcr.ConsumeName, &pcr.ConsumeType, &pcr.LimitNum, &pcr.ConsumeUnit, &pcr.ConsumeUnitNum, &pcr.CurrentReservationNum, &pcr.IsGroupBuy, &pcr.IsWaiting, &pcr.ReserveStatus, &pcr.ReserveMethod, &pcr.IsCheckin, &pcr.CheckinMethod, &pcr.ReserveID, &pcr.CheckinID, &pcr.CheckinTime, &pcr.StartDate, &pcr.StartTime, &pcr.EndTime, &pcr.IsDel, &pcr.CreatedTime, &pcr.UpdatedTime)
		if err != nil {
			return nil, err
		}
	}

	return &pcr, nil
}
