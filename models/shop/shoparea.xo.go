// Package tmp contains the types for schema 'saas'.
package shopModel

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	"github.com/Masterminds/squirrel"
	"j7go/components"
	"j7go/utils"

	"go.uber.org/zap"
)

// ShopArea represents a row from 'saas.shop_area'.
type ShopArea struct {
	ID            uint   `json:"id"`             // id
	BrandID       uint   `json:"brand_id"`       // brand_id
	ShopID        uint   `json:"shop_id"`        // shop_id
	AreaName      string `json:"area_name"`      // area_name
	ContainNumber uint   `json:"contain_number"` // contain_number
	IsVip         int8   `json:"is_vip"`         // is_vip
	IsDel         int8   `json:"is_del"`         // is_del
	CreatedTime   uint   `json:"created_time"`   // created_time
	UpdatedTime   uint   `json:"updated_time"`   // updated_time

	// xo fields
	_exists, _deleted bool
}

// Exists determines if the ShopArea exists in the database.
func (sa *ShopArea) Exists() bool { //shop_area
	return sa._exists
}

// Deleted provides information if the ShopArea has been deleted from the database.
func (sa *ShopArea) Deleted() bool {
	return sa._deleted
}

// Get table name
func GetShopAreaTableName(key ...interface{}) (string, error) {
	tableName, err := components.M.GetTable("saas", "shop_area", key...)
	if err != nil {
		return "", err
	}
	return tableName, nil
}

// Insert inserts the ShopArea to the database.
func (sa *ShopArea) Insert(ctx context.Context, key ...interface{}) error {
	var err error
	var dbConn *sql.DB
	var res sql.Result
	// if already exist, bail
	if sa._exists {
		return errors.New("insert failed: already exists")
	}

	tx, err := components.M.GetConnFromCtx(ctx)
	if err != nil {
		dbConn, err = components.M.GetMasterConn()
		if err != nil {
			return err
		}
	}

	tableName, err := GetShopAreaTableName(key...)
	if err != nil {
		return err
	}

	// sql insert query, primary key provided by autoincrement
	sqlstr := `INSERT INTO ` + tableName +
		` (` +
		`brand_id, shop_id, area_name, contain_number, is_vip, is_del, created_time, updated_time` +
		`) VALUES (` +
		`?, ?, ?, ?, ?, ?, ?, ?` +
		`)`

	// run query
	utils.GetTraceLog(ctx).Debug("DB", zap.String("SQL", fmt.Sprint(sqlstr, sa.BrandID, sa.ShopID, sa.AreaName, sa.ContainNumber, sa.IsVip, sa.IsDel, sa.CreatedTime, sa.UpdatedTime)))
	if err != nil {
		return err
	}
	if tx != nil {
		res, err = tx.Exec(sqlstr, sa.BrandID, sa.ShopID, sa.AreaName, sa.ContainNumber, sa.IsVip, sa.IsDel, sa.CreatedTime, sa.UpdatedTime)
	} else {
		res, err = dbConn.Exec(sqlstr, sa.BrandID, sa.ShopID, sa.AreaName, sa.ContainNumber, sa.IsVip, sa.IsDel, sa.CreatedTime, sa.UpdatedTime)
	}

	if err != nil {
		return err
	}

	// retrieve id
	id, err := res.LastInsertId()
	if err != nil {
		return err
	}

	// set primary key and existence
	sa.ID = uint(id)
	sa._exists = true

	return nil
}

// Update updates the ShopArea in the database.
func (sa *ShopArea) Update(ctx context.Context, key ...interface{}) error {
	var err error
	var dbConn *sql.DB

	// if deleted, bail
	if sa._deleted {
		return errors.New("update failed: marked for deletion")
	}

	tx, err := components.M.GetConnFromCtx(ctx)
	if err != nil {
		dbConn, err = components.M.GetMasterConn()
		if err != nil {
			return err
		}
	}

	tableName, err := GetShopAreaTableName(key...)
	if err != nil {
		return err
	}

	// sql query
	sqlstr := `UPDATE ` + tableName + ` SET ` +
		`brand_id = ?, shop_id = ?, area_name = ?, contain_number = ?, is_vip = ?, is_del = ?, created_time = ?, updated_time = ?` +
		` WHERE id = ?`

	// run query
	utils.GetTraceLog(ctx).Debug("DB", zap.String("SQL", fmt.Sprint(sqlstr, sa.BrandID, sa.ShopID, sa.AreaName, sa.ContainNumber, sa.IsVip, sa.IsDel, sa.CreatedTime, sa.UpdatedTime, sa.ID)))
	if tx != nil {
		_, err = tx.Exec(sqlstr, sa.BrandID, sa.ShopID, sa.AreaName, sa.ContainNumber, sa.IsVip, sa.IsDel, sa.CreatedTime, sa.UpdatedTime, sa.ID)
	} else {
		_, err = dbConn.Exec(sqlstr, sa.BrandID, sa.ShopID, sa.AreaName, sa.ContainNumber, sa.IsVip, sa.IsDel, sa.CreatedTime, sa.UpdatedTime, sa.ID)
	}
	return err
}

// Save saves the ShopArea to the database.
func (sa *ShopArea) Save(ctx context.Context) error {
	if sa.Exists() {
		return sa.Update(ctx)
	}

	return sa.Insert(ctx)
}

// Delete deletes the ShopArea from the database.
func (sa *ShopArea) Delete(ctx context.Context, key ...interface{}) error {
	var err error
	var dbConn *sql.DB

	// if deleted, bail
	if sa._deleted {
		return nil
	}

	tx, err := components.M.GetConnFromCtx(ctx)
	if err != nil {
		dbConn, err = components.M.GetMasterConn()
		if err != nil {
			return err
		}
	}

	tableName, err := GetShopAreaTableName(key...)
	if err != nil {
		return err
	}
	//1

	// sql query with composite primary key
	sqlstr := `UPDATE ` + tableName + ` SET is_del = 1 WHERE id = ?`

	// run query
	utils.GetTraceLog(ctx).Debug("DB", zap.String("SQL", fmt.Sprint(sqlstr, sa.ID)))
	if tx != nil {
		_, err = tx.Exec(sqlstr, sa.ID)
	} else {
		_, err = dbConn.Exec(sqlstr, sa.ID)
	}

	if err != nil {
		return err
	}

	// set deleted
	sa._deleted = true

	return nil
}

// ShopAreaByID retrieves a row from 'saas.shop_area' as a ShopArea.
//
// Generated from index 'shop_area_id_pkey'.
func ShopAreaByID(ctx context.Context, id uint, key ...interface{}) (*ShopArea, error) {
	var err error
	var dbConn *sql.DB

	tableName, err := GetShopAreaTableName(key...)
	if err != nil {
		return nil, err
	}

	// sql query
	sqlstr := `SELECT ` +
		`id, brand_id, shop_id, area_name, contain_number, is_vip, is_del, created_time, updated_time ` +
		`FROM ` + tableName +
		` WHERE id = ?`

	// run query
	utils.GetTraceLog(ctx).Debug("DB", zap.String("SQL", fmt.Sprint(sqlstr, id)))

	tx, err := components.M.GetConnFromCtx(ctx)
	if err != nil {
		dbConn, err = components.M.GetSlaveConn()
		if err != nil {
			return nil, err
		}
	}
	sa := ShopArea{
		_exists: true,
	}

	if tx != nil {
		err = tx.QueryRow(sqlstr, id).Scan(&sa.ID, &sa.BrandID, &sa.ShopID, &sa.AreaName, &sa.ContainNumber, &sa.IsVip, &sa.IsDel, &sa.CreatedTime, &sa.UpdatedTime)
		if err != nil {
			return nil, err
		}
	} else {
		err = dbConn.QueryRow(sqlstr, id).Scan(&sa.ID, &sa.BrandID, &sa.ShopID, &sa.AreaName, &sa.ContainNumber, &sa.IsVip, &sa.IsDel, &sa.CreatedTime, &sa.UpdatedTime)
		if err != nil {
			return nil, err
		}
	}

	return &sa, nil
}

func GetShopAreaByIds(ctx context.Context, Ids []uint, key ...interface{}) ([]*ShopArea, error) {
	var err error
	var dbConn *sql.DB
	var shopAreaList = make([]*ShopArea, 0)
	var rows *sql.Rows

	tableName, err := GetShopAreaTableName(key...)
	if err != nil {
		return nil, err
	}

	tx, err := components.M.GetConnFromCtx(ctx)
	if err != nil {
		dbConn, err = components.M.GetSlaveConn()
		if err != nil {
			return nil, err
		}
	}

	sqlBuilder :=
		squirrel.Select(
			"id",
			"brand_id",
			"shop_id",
			"area_name",
			"contain_number",
			"is_vip",
			"is_del",
			"created_time",
			"updated_time").
			From(tableName).
			Where(squirrel.Eq{"is_del": utils.Unavailable, "id": Ids})

	sqlStr, arg, err := sqlBuilder.ToSql()
	if err != nil {
		return nil, err
	}

	// run query
	utils.GetTraceLog(ctx).Debug("DB", zap.String("SQL", fmt.Sprint(sqlStr, arg)))
	if tx != nil {
		rows, err = tx.Query(sqlStr, arg...)
		if err != nil && err != sql.ErrNoRows {
			return nil, err
		}
	} else {
		rows, err = dbConn.Query(sqlStr, arg...)
		if err != nil && err != sql.ErrNoRows {
			return nil, err
		}
	}

	defer rows.Close()

	for rows.Next() {
		shopArea := ShopArea{}
		err := rows.Scan(&shopArea.ID,
			&shopArea.BrandID,
			&shopArea.ShopID,
			&shopArea.AreaName,
			&shopArea.ContainNumber,
			&shopArea.IsVip,
			&shopArea.IsDel,
			&shopArea.CreatedTime,
			&shopArea.UpdatedTime,
		)
		if err != nil {
			return nil, err
		}

		shopAreaList = append(shopAreaList, &shopArea)
	}

	return shopAreaList, nil
}
