// Package xo contains the types for schema 'saas'.
package imagesModel

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	"github.com/Masterminds/squirrel"
	"go.uber.org/zap"
	"j7go/components"
	"j7go/utils"
)

// Image represents a row from 'saas.images'.
type Image struct {
	ID          uint   `json:"id"`           // id
	AlbumID     uint   `json:"album_id"`     // album_id
	ImageURL    string `json:"image_url"`    // image_url
	CoverType   int8   `json:"cover_type"`   // cover_type
	IsDel       int8   `json:"is_del"`       // is_del
	CreatedTime uint   `json:"created_time"` // created_time
	UpdatedTime uint   `json:"updated_time"` // updated_time

	// xo fields
	_exists, _deleted bool
}

//图片类型
const (
	//普通图片
	COVER_TYPE_GENERAL = 1
	//封面
	COVER_TYPE_COVER = 2
	//logo
	COVER_TYPE_LOGO = 3
	//头像
	COVER_TYPE_HEAD = 4
	//人脸
	COVER_TYPE_FACE = 5
)

// Exists determines if the Image exists in the database.
func (i *Image) Exists() bool { //images
	return i._exists
}

// Deleted provides information if the Image has been deleted from the database.
func (i *Image) Deleted() bool {
	return i._deleted
}

// Get table name
func GetImageTableName(key ...interface{}) (string, error) {
	tableName, err := components.M.GetTable("saas", "images", key...)
	if err != nil {
		return "", err
	}
	return tableName, nil
}

// Insert inserts the Image to the database.
func (i *Image) Insert(ctx context.Context, key ...interface{}) error {
	var err error
	var dbConn *sql.DB
	// if already exist, bail
	if i._exists {
		return errors.New("insert failed: already exists")
	}

	tx, err := components.M.GetConnFromCtx(ctx)
	if err != nil {
		dbConn, err = components.M.GetMasterConn()
		if err != nil {
			return err
		}
	}

	tableName, err := GetImageTableName(key...)
	if err != nil {
		return err
	}

	var res sql.Result
	// sql insert query, primary key provided by autoincrement
	sqlstr := `INSERT INTO ` + tableName +
		` (` +
		`album_id, image_url, cover_type, is_del, created_time, updated_time` +
		`) VALUES (` +
		`?, ?, ?, ?, ?, ?` +
		`)`

	// run query
	utils.GetTraceLog(ctx).Debug("DB", zap.String("SQL", fmt.Sprint(sqlstr, i.AlbumID, i.ImageURL, i.CoverType, i.IsDel, i.CreatedTime, i.UpdatedTime)))
	if err != nil {
		return err
	}
	if tx != nil {
		res, err = tx.Exec(sqlstr, i.AlbumID, i.ImageURL, i.CoverType, i.IsDel, i.CreatedTime, i.UpdatedTime)
	} else {
		res, err = dbConn.Exec(sqlstr, i.AlbumID, i.ImageURL, i.CoverType, i.IsDel, i.CreatedTime, i.UpdatedTime)
	}

	// retrieve id
	id, err := res.LastInsertId()
	if err != nil {
		return err
	}

	// set primary key and existence
	i.ID = uint(id)
	i._exists = true

	return nil
}

// Update updates the Image in the database.
func (i *Image) Update(ctx context.Context, key ...interface{}) error {
	var err error
	var dbConn *sql.DB

	// if deleted, bail
	if i._deleted {
		return errors.New("update failed: marked for deletion")
	}

	tx, err := components.M.GetConnFromCtx(ctx)
	if err != nil {
		dbConn, err = components.M.GetMasterConn()
		if err != nil {
			return err
		}
	}

	tableName, err := GetImageTableName(key...)
	if err != nil {
		return err
	}

	// sql query
	sqlstr := `UPDATE ` + tableName + ` SET ` +
		`album_id = ?, image_url = ?, cover_type = ?, is_del = ?, created_time = ?, updated_time = ?` +
		` WHERE id = ?`

	// run query
	utils.GetTraceLog(ctx).Debug("DB", zap.String("SQL", fmt.Sprint(sqlstr, i.AlbumID, i.ImageURL, i.CoverType, i.IsDel, i.CreatedTime, i.UpdatedTime, i.ID)))
	if tx != nil {
		_, err = tx.Exec(sqlstr, i.AlbumID, i.ImageURL, i.CoverType, i.IsDel, i.CreatedTime, i.UpdatedTime, i.ID)
	} else {
		_, err = dbConn.Exec(sqlstr, i.AlbumID, i.ImageURL, i.CoverType, i.IsDel, i.CreatedTime, i.UpdatedTime, i.ID)
	}
	return err
}

// Save saves the Image to the database.
func (i *Image) Save(ctx context.Context) error {
	if i.Exists() {
		return i.Update(ctx)
	}

	return i.Insert(ctx)
}

// Delete deletes the Image from the database.
func (i *Image) Delete(ctx context.Context, key ...interface{}) error {
	var err error
	var dbConn *sql.DB

	// if deleted, bail
	if i._deleted {
		return nil
	}

	tx, err := components.M.GetConnFromCtx(ctx)
	if err != nil {
		dbConn, err = components.M.GetMasterConn()
		if err != nil {
			return err
		}
	}

	tableName, err := GetImageTableName(key...)
	if err != nil {
		return err
	}
	//1

	// sql query with composite primary key
	sqlstr := `UPDATE ` + tableName + ` SET is_del = 1 WHERE id = ?`

	// run query
	utils.GetTraceLog(ctx).Debug("DB", zap.String("SQL", fmt.Sprint(sqlstr, i.ID)))
	if tx != nil {
		_, err = tx.Exec(sqlstr, i.ID)
	} else {
		_, err = dbConn.Exec(sqlstr, i.ID)
	}

	if err != nil {
		return err
	}

	// set deleted
	i._deleted = true

	return nil
}

// ImageByID retrieves a row from 'saas.images' as a Image.
//
// Generated from index 'images_id_pkey'.
func ImageByID(ctx context.Context, id uint, key ...interface{}) (*Image, error) {
	var err error
	var dbConn *sql.DB

	tableName, err := GetImageTableName(key...)
	if err != nil {
		return nil, err
	}

	// sql query
	sqlstr := `SELECT ` +
		`id, album_id, image_url, cover_type, is_del, created_time, updated_time ` +
		`FROM ` + tableName +
		` WHERE id = ? and is_del = ?`

	// run query
	utils.GetTraceLog(ctx).Debug("DB", zap.String("SQL", fmt.Sprint(sqlstr, id, utils.NOT_DELETED)))

	tx, err := components.M.GetConnFromCtx(ctx)
	if err != nil {
		dbConn, err = components.M.GetSlaveConn()
		if err != nil {
			return nil, err
		}
	}
	i := Image{
		_exists: true,
	}

	if tx != nil {
		err = tx.QueryRow(sqlstr, id, utils.NOT_DELETED).Scan(&i.ID, &i.AlbumID, &i.ImageURL, &i.CoverType, &i.IsDel, &i.CreatedTime, &i.UpdatedTime)
		if err != nil {
			return nil, err
		}
	} else {
		err = dbConn.QueryRow(sqlstr, id, utils.NOT_DELETED).Scan(&i.ID, &i.AlbumID, &i.ImageURL, &i.CoverType, &i.IsDel, &i.CreatedTime, &i.UpdatedTime)
		if err != nil {
			return nil, err
		}
	}

	return &i, nil
}

// 获取相册指定类型图片
func GetAlbumImagesByCoverType(ctx context.Context, albumId uint, coverType int8, key ...interface{}) ([]*Image, error) {
	var err error
	var dbConn *sql.DB
	var rows *sql.Rows

	tableName, err := GetImageTableName(key...)
	if err != nil {
		return nil, err
	}

	// sql query
	sqlstr := `SELECT ` +
		`id, album_id, image_url, cover_type, is_del, created_time, updated_time ` +
		`FROM ` + tableName +
		` WHERE album_id = ? AND cover_type = ? AND is_del = ?`

	// run query
	utils.GetTraceLog(ctx).Debug("DB", zap.String("SQL", fmt.Sprint(sqlstr, albumId, coverType, utils.Unavailable)))

	tx, err := components.M.GetConnFromCtx(ctx)
	if err != nil {
		dbConn, err = components.M.GetSlaveConn()
		if err != nil {
			return nil, err
		}
	}
	if tx != nil {
		rows, err = tx.Query(sqlstr, albumId, coverType, utils.Unavailable)
	} else {
		rows, err = dbConn.Query(sqlstr, albumId, coverType, utils.Unavailable)
	}
	if err != nil {
		return nil, err
	}

	images := make([]*Image, 0)
	for rows.Next() {
		i := Image{
			_exists: true,
		}

		err = rows.Scan(&i.ID, &i.AlbumID, &i.ImageURL, &i.CoverType, &i.IsDel, &i.CreatedTime, &i.UpdatedTime)
		if err != nil {
			return nil, err
		}
		images = append(images, &i)
	}
	utils.GetTraceLog(ctx).Debug("DB", zap.Any("SQL", images))
	err = rows.Close()

	return images, nil
}

// 获取相册图片 返回 slice
func GetAlbumImages(ctx context.Context, albumId uint, key ...interface{}) ([]*Image, error) {
	var err error
	var dbConn *sql.DB
	var rows *sql.Rows

	tableName, err := GetImageTableName(key...)
	if err != nil {
		return nil, err
	}

	// sql query
	sqlstr := `SELECT ` +
		`id, album_id, image_url, cover_type, is_del, created_time, updated_time ` +
		`FROM ` + tableName +
		` WHERE album_id = ? AND is_del = ?`

	// run query
	utils.GetTraceLog(ctx).Debug("DB", zap.String("SQL", fmt.Sprint(sqlstr, albumId, utils.Unavailable)))

	tx, err := components.M.GetConnFromCtx(ctx)
	if err != nil {
		dbConn, err = components.M.GetSlaveConn()
		if err != nil {
			return nil, err
		}
	}

	if tx != nil {
		rows, err = tx.Query(sqlstr, albumId, utils.Unavailable)
		if err != nil {
			return nil, err
		}
	} else {
		rows, err = dbConn.Query(sqlstr, albumId, utils.Unavailable)
		if err != nil {
			return nil, err
		}
	}
	defer rows.Close()

	images := make([]*Image, 0)
	for rows.Next() {
		i := Image{
			_exists: true,
		}

		err = rows.Scan(&i.ID, &i.AlbumID, &i.ImageURL, &i.CoverType, &i.IsDel, &i.CreatedTime, &i.UpdatedTime)
		if err != nil {
			return nil, err
		}
		images = append(images, &i)
	}
	utils.GetTraceLog(ctx).Debug("DB", zap.Any("images", images))

	return images, nil
}

func DeleteCoverImage(ctx context.Context, albumId uint, coverType int8, key ...interface{}) error {
	var err error
	var dbConn *sql.DB

	tx, err := components.M.GetConnFromCtx(ctx)
	if err != nil {
		dbConn, err = components.M.GetMasterConn()
		if err != nil {
			return err
		}
	}

	tableName, err := GetImageTableName(key...)
	if err != nil {
		return err
	}

	// sql query with composite primary key
	sqlstr := `UPDATE ` + tableName + ` SET is_del = 1 WHERE album_id = ? AND cover_type = ? AND is_del = ?`

	// run query
	utils.GetTraceLog(ctx).Debug("DB", zap.String("SQL", fmt.Sprint(sqlstr, albumId, coverType, utils.Unavailable)))
	if tx != nil {
		_, err = tx.Exec(sqlstr, albumId, coverType, utils.Unavailable)
	} else {
		_, err = dbConn.Exec(sqlstr, albumId, coverType, utils.Unavailable)
	}

	if err != nil {
		return err
	}

	return nil
}

//批量获取多相册特定coverType的图片
func GetImages(ctx context.Context, coverType int8, albumIds []uint32, key ...interface{}) ([]*Image, error) {
	var err error
	var dbConn *sql.DB
	var rows *sql.Rows

	tx, err := components.M.GetConnFromCtx(ctx)
	if err != nil {
		dbConn, err = components.M.GetSlaveConn()
		if err != nil {
			return nil, err
		}
	}

	imagesTableName, _ := GetImageTableName(key...)
	albumTableName, _ := GetAlbumTableName(key...)
	sqlBuilder := squirrel.Select(
		imagesTableName+".id",
		imagesTableName+".album_id",
		imagesTableName+".image_url",
		imagesTableName+".cover_type",
	).
		From(imagesTableName).
		LeftJoin(albumTableName + " on " + imagesTableName + ".album_id = " + albumTableName + ".id").
		Where(
			squirrel.Eq{
				"album.id":          albumIds,
				"images.cover_type": coverType,
				"images.is_del":     utils.NOT_DELETED,
				"album.is_del":      utils.NOT_DELETED,
			})

	sqlStr, args, err := sqlBuilder.ToSql()
	utils.GetTraceLog(ctx).Debug("DB", zap.String("SQL", fmt.Sprint(sqlStr, albumIds, coverType)), zap.Any("args", args))

	if tx != nil {
		rows, err = tx.Query(sqlStr, args...)
	} else {
		rows, err = dbConn.Query(sqlStr, args...)
	}
	if err != nil {
		return nil, err
	}

	images := make([]*Image, 0)
	for rows.Next() {
		i := Image{
			_exists: true,
		}

		err = rows.Scan(&i.ID, &i.AlbumID, &i.ImageURL, &i.CoverType)
		if err != nil {
			return nil, err
		}
		images = append(images, &i)
	}

	err = rows.Close()
	if err != nil {
		return nil, err
	}

	return images, nil
}

//批量上传图片
func ImagesBatchInsert(ctx context.Context, imageList []*Image, key ...interface{}) error {
	var err error
	var dbConn *sql.DB

	tx, err := components.M.GetConnFromCtx(ctx)
	if err != nil {
		dbConn, err = components.M.GetMasterConn()
		if err != nil {
			return err
		}
	}

	tableName, err := GetImageTableName(key...)
	if err != nil {
		return err
	}

	// sql insert query, primary key must be provided
	sqlBuilder := squirrel.
		Insert(tableName).
		Columns("album_id", "image_url", "cover_type", "is_del", "created_time", "updated_time")

	for _, image := range imageList {
		sqlBuilder = sqlBuilder.Values(image.AlbumID, image.ImageURL, image.CoverType, image.IsDel, image.CreatedTime, image.UpdatedTime)
	}

	sqlstr, args, err := sqlBuilder.ToSql()
	if err != nil {
		return err
	}

	// run query
	utils.GetTraceLog(ctx).Debug("DB", zap.String("SQL", fmt.Sprint(sqlstr)), zap.Any("args", args))
	if tx != nil {
		_, err = tx.Exec(sqlstr, args...)
	} else {
		_, err = dbConn.Exec(sqlstr, args...)
	}

	if err != nil {
		return err
	}

	return nil
}

//根据类型获取单张图片
func GetImagesByID(ctx context.Context, albumId uint, coverType int8) (*Image, error) {
	var err error
	var dbConn *sql.DB

	tableName, err := GetImageTableName()
	if err != nil {
		return nil, err
	}

	// sql query
	sqlstr := `SELECT ` +
		`id, album_id, image_url, cover_type, is_del, created_time, updated_time ` +
		`FROM ` + tableName +
		` WHERE album_id = ? and cover_type = ? and is_del = ?`

	// run query
	utils.GetTraceLog(ctx).Debug("DB", zap.String("SQL", fmt.Sprint(sqlstr, albumId, coverType, utils.NOT_DELETED)))

	tx, err := components.M.GetConnFromCtx(ctx)
	if err != nil {
		dbConn, err = components.M.GetSlaveConn()
		if err != nil {
			return nil, err
		}
	}
	i := Image{
		_exists: true,
	}

	if tx != nil {
		err = tx.QueryRow(sqlstr, albumId, coverType, utils.NOT_DELETED).Scan(&i.ID, &i.AlbumID, &i.ImageURL, &i.CoverType, &i.IsDel, &i.CreatedTime, &i.UpdatedTime)
		if err != nil {
			return nil, err
		}
	} else {
		err = dbConn.QueryRow(sqlstr, albumId, coverType, utils.NOT_DELETED).Scan(&i.ID, &i.AlbumID, &i.ImageURL, &i.CoverType, &i.IsDel, &i.CreatedTime, &i.UpdatedTime)
		if err != nil {
			return nil, err
		}
	}

	return &i, nil
}

func GetImagesByAlbumId(ctx context.Context, albumId uint, key ...interface{}) ([]*Image, error) {
	var err error
	var dbConn *sql.DB

	tableName, err := GetImageTableName(key...)
	if err != nil {
		return nil, err
	}

	// sql query
	sqlstr := `SELECT ` +
		`id, image_url` +
		`FROM ` + tableName +
		` WHERE album_id = ? AND is_del = 0`

	// run query
	utils.GetTraceLog(ctx).Debug("DB", zap.String("SQL,get_image_by_album_id", fmt.Sprint(sqlstr, albumId)))

	tx, err := components.M.GetConnFromCtx(ctx)
	if err != nil {
		dbConn, err = components.M.GetSlaveConn()
		if err != nil {
			return nil, err
		}
	}

	var rows *sql.Rows
	if tx != nil {
		rows, err = tx.Query(sqlstr, albumId)
		if err != nil {
			return nil, err
		}
	} else {
		rows, err = dbConn.Query(sqlstr, albumId)
		if err != nil {
			return nil, err
		}
	}
	defer rows.Close()

	// load results
	res := make([]*Image, 0)
	for rows.Next() {
		img := Image{
			_exists: true,
		}

		// scan
		err = rows.Scan(&img.ID, &img.ImageURL)
		if err != nil {
			return nil, err
		}

		res = append(res, &img)
	}

	return res, nil
}

//批量删除图片
func BatchDeleteImages(ctx context.Context, imageIds []uint32, key ...interface{}) error {
	var dbConn *sql.DB

	tableName, err := GetImageTableName(key...)
	if err != nil {
		return err
	}

	sqlstr, args, err := squirrel.
		Update(tableName).
		Set("is_del", utils.DELETED).
		Where(squirrel.Eq{"id": imageIds}).
		ToSql()

	utils.GetTraceLog(ctx).Debug("DB", zap.String("SQL,batch_delete_images", fmt.Sprint(sqlstr)), zap.Any("args", args))

	tx, err := components.M.GetConnFromCtx(ctx)
	if err != nil {
		dbConn, err = components.M.GetMasterConn()
		if err != nil {
			return err
		}
	}

	if tx != nil {
		_, err := tx.Exec(sqlstr, args...)
		if err != nil {
			return err
		}
	} else {
		_, err := dbConn.Exec(sqlstr, args...)
		if err != nil {
			return err
		}
	}

	return nil
}

// 获取相册图片 返回 map
func GetAlbumImagesIndexById(ctx context.Context, albumId uint, key ...interface{}) (map[uint32]*Image, error) {
	var err error
	var dbConn *sql.DB
	var rows *sql.Rows

	tableName, err := GetImageTableName(key...)
	if err != nil {
		return nil, err
	}

	sqlstr, args, err := squirrel.
		Select("id", "album_id", "image_url", "cover_type").
		From(tableName).
		Where(squirrel.Eq{"album_id": albumId, "is_del": utils.Unavailable}).
		ToSql()

	utils.GetTraceLog(ctx).Debug("DB", zap.String("SQL", fmt.Sprint(sqlstr)), zap.Any("args", args))

	tx, err := components.M.GetConnFromCtx(ctx)
	if err != nil {
		dbConn, err = components.M.GetSlaveConn()
		if err != nil {
			return nil, err
		}
	}

	if tx != nil {
		rows, err = tx.Query(sqlstr, albumId, utils.Unavailable)
		if err != nil {
			return nil, err
		}
	} else {
		rows, err = dbConn.Query(sqlstr, albumId, utils.Unavailable)
		if err != nil {
			return nil, err
		}
	}
	defer rows.Close()

	images := make(map[uint32]*Image, 0)
	for rows.Next() {
		i := Image{
			_exists: true,
		}

		err = rows.Scan(&i.ID, &i.AlbumID, &i.ImageURL, &i.CoverType)
		if err != nil {
			return nil, err
		}
		images[uint32(i.ID)] = &i
	}
	utils.GetTraceLog(ctx).Debug("DB", zap.Any("Images", images))

	return images, nil
}

//更新图片cover_type
func UpdateImageType(ctx context.Context, imageId uint32, coverType uint8, key ...interface{}) error {
	var dbConn *sql.DB

	tableName, err := GetImageTableName(key...)
	if err != nil {
		return err
	}

	sqlstr, args, err := squirrel.Update(tableName).Set("cover_type", coverType).Where(squirrel.Eq{"id": imageId}).ToSql()

	utils.GetTraceLog(ctx).Debug("DB", zap.String("SQL,update_image_type", fmt.Sprint(sqlstr)), zap.Any("args", args))

	tx, err := components.M.GetConnFromCtx(ctx)
	if err != nil {
		dbConn, err = components.M.GetMasterConn()
		if err != nil {
			return err
		}
	}

	if tx != nil {
		_, err := tx.Exec(sqlstr, args...)
		if err != nil {
			return err
		}
	} else {
		_, err := dbConn.Exec(sqlstr, args...)
		if err != nil {
			return err
		}
	}

	return nil
}
