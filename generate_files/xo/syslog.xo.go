// Package xo contains the types for schema 'aypcddg'.
package xo

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	"j7go/components"
	"j7go/utils"
	"time"

	"go.uber.org/zap"
)

// Syslog represents a row from 'aypcddg.syslog'.
type Syslog struct {
	ID         uint           `json:"id"`         // id
	Ipaddress  sql.NullString `json:"ipaddress"`  // ipaddress
	URL        sql.NullString `json:"url"`        // url
	Referer    string         `json:"referer"`    // referer
	Adddt      time.Time      `json:"adddt"`      // adddt
	Guestcode  string         `json:"guestcode"`  // guestcode
	Param      sql.NullString `json:"param"`      // param
	Module     sql.NullString `json:"module"`     // module
	Control    sql.NullString `json:"control"`    // control
	UID        sql.NullInt64  `json:"uid"`        // uid
	Cid        int            `json:"cid"`        // cid
	Gid        sql.NullInt64  `json:"gid"`        // gid
	Vid        sql.NullInt64  `json:"vid"`        // vid
	Iplocation string         `json:"iplocation"` // iplocation
	Useragent  sql.NullString `json:"useragent"`  // useragent
	Sagent     sql.NullString `json:"sagent"`     // sagent
	Addtime    sql.NullInt64  `json:"addtime"`    // addtime

	// xo fields
	_exists, _deleted bool
}

// Exists determines if the Syslog exists in the database.
func (s *Syslog) Exists() bool { //syslog
	return s._exists
}

// Deleted provides information if the Syslog has been deleted from the database.
func (s *Syslog) Deleted() bool {
	return s._deleted
}

// Get table name
func GetSyslogTableName(key ...interface{}) (string, error) {
	tableName, err := components.M.GetTable("aypcddg", "syslog", key...)
	if err != nil {
		return "", err
	}
	return tableName, nil
}

// Insert inserts the Syslog to the database.
func (s *Syslog) Insert(ctx context.Context, key ...interface{}) error {
	var err error
	var dbConn *sql.DB
	var res sql.Result
	// if already exist, bail
	if s._exists {
		return errors.New("insert failed: already exists")
	}

	tx, err := components.M.GetConnFromCtx(ctx)
	if err != nil {
		dbConn, err = components.M.GetMasterConn()
		if err != nil {
			return err
		}
	}

	tableName, err := GetSyslogTableName(key...)
	if err != nil {
		return err
	}

	// sql insert query, primary key provided by autoincrement
	sqlstr := `INSERT INTO ` + tableName +
		` (` +
		`ipaddress, url, referer, adddt, guestcode, param, module, control, uid, cid, gid, vid, iplocation, useragent, sagent, addtime` +
		`) VALUES (` +
		`?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?` +
		`)`

	// run query
	utils.GetTraceLog(ctx).Debug("DB", zap.String("SQL", fmt.Sprint(sqlstr, s.Ipaddress, s.URL, s.Referer, s.Adddt, s.Guestcode, s.Param, s.Module, s.Control, s.UID, s.Cid, s.Gid, s.Vid, s.Iplocation, s.Useragent, s.Sagent, s.Addtime)))
	if err != nil {
		return err
	}
	if tx != nil {
		res, err = tx.Exec(sqlstr, s.Ipaddress, s.URL, s.Referer, s.Adddt, s.Guestcode, s.Param, s.Module, s.Control, s.UID, s.Cid, s.Gid, s.Vid, s.Iplocation, s.Useragent, s.Sagent, s.Addtime)
	} else {
		res, err = dbConn.Exec(sqlstr, s.Ipaddress, s.URL, s.Referer, s.Adddt, s.Guestcode, s.Param, s.Module, s.Control, s.UID, s.Cid, s.Gid, s.Vid, s.Iplocation, s.Useragent, s.Sagent, s.Addtime)
	}

	if err != nil {
		return err
	}

	// retrieve id
	id, err := res.LastInsertId()
	if err != nil {
		return err
	}

	// set primary key and existence
	s.ID = uint(id)
	s._exists = true

	return nil
}

// Update updates the Syslog in the database.
func (s *Syslog) Update(ctx context.Context, key ...interface{}) error {
	var err error
	var dbConn *sql.DB

	// if deleted, bail
	if s._deleted {
		return errors.New("update failed: marked for deletion")
	}

	tx, err := components.M.GetConnFromCtx(ctx)
	if err != nil {
		dbConn, err = components.M.GetMasterConn()
		if err != nil {
			return err
		}
	}

	tableName, err := GetSyslogTableName(key...)
	if err != nil {
		return err
	}

	// sql query
	sqlstr := `UPDATE ` + tableName + ` SET ` +
		`ipaddress = ?, url = ?, referer = ?, adddt = ?, guestcode = ?, param = ?, module = ?, control = ?, uid = ?, cid = ?, gid = ?, vid = ?, iplocation = ?, useragent = ?, sagent = ?, addtime = ?` +
		` WHERE id = ?`

	// run query
	utils.GetTraceLog(ctx).Debug("DB", zap.String("SQL", fmt.Sprint(sqlstr, s.Ipaddress, s.URL, s.Referer, s.Adddt, s.Guestcode, s.Param, s.Module, s.Control, s.UID, s.Cid, s.Gid, s.Vid, s.Iplocation, s.Useragent, s.Sagent, s.Addtime, s.ID)))
	if tx != nil {
		_, err = tx.Exec(sqlstr, s.Ipaddress, s.URL, s.Referer, s.Adddt, s.Guestcode, s.Param, s.Module, s.Control, s.UID, s.Cid, s.Gid, s.Vid, s.Iplocation, s.Useragent, s.Sagent, s.Addtime, s.ID)
	} else {
		_, err = dbConn.Exec(sqlstr, s.Ipaddress, s.URL, s.Referer, s.Adddt, s.Guestcode, s.Param, s.Module, s.Control, s.UID, s.Cid, s.Gid, s.Vid, s.Iplocation, s.Useragent, s.Sagent, s.Addtime, s.ID)
	}
	return err
}

// Save saves the Syslog to the database.
func (s *Syslog) Save(ctx context.Context) error {
	if s.Exists() {
		return s.Update(ctx)
	}

	return s.Insert(ctx)
}

// Delete deletes the Syslog from the database.
func (s *Syslog) Delete(ctx context.Context, key ...interface{}) error {
	var err error
	var dbConn *sql.DB

	// if deleted, bail
	if s._deleted {
		return nil
	}

	tx, err := components.M.GetConnFromCtx(ctx)
	if err != nil {
		dbConn, err = components.M.GetMasterConn()
		if err != nil {
			return err
		}
	}

	tableName, err := GetSyslogTableName(key...)
	if err != nil {
		return err
	}
	//1

	// sql query with composite primary key
	sqlstr := `UPDATE ` + tableName + ` SET is_del = 1 WHERE id = ?`

	// run query
	utils.GetTraceLog(ctx).Debug("DB", zap.String("SQL", fmt.Sprint(sqlstr, s.ID)))
	if tx != nil {
		_, err = tx.Exec(sqlstr, s.ID)
	} else {
		_, err = dbConn.Exec(sqlstr, s.ID)
	}

	if err != nil {
		return err
	}

	// set deleted
	s._deleted = true

	return nil
}

// SyslogsByIpaddress retrieves a row from 'aypcddg.syslog' as a Syslog.
//
// Generated from index 'idx_ipaddress'.
func SyslogsByIpaddress(ctx context.Context, ipaddress sql.NullString, key ...interface{}) ([]*Syslog, error) {
	var err error
	var dbConn *sql.DB

	tableName, err := GetSyslogTableName(key...)
	if err != nil {
		return nil, err
	}

	// sql query
	sqlstr := `SELECT ` +
		`id, ipaddress, url, referer, adddt, guestcode, param, module, control, uid, cid, gid, vid, iplocation, useragent, sagent, addtime ` +
		`FROM ` + tableName +
		` WHERE ipaddress = ?`

	// run query
	utils.GetTraceLog(ctx).Debug("DB", zap.String("SQL", fmt.Sprint(sqlstr, ipaddress)))

	tx, err := components.M.GetConnFromCtx(ctx)
	if err != nil {
		dbConn, err = components.M.GetSlaveConn()
		if err != nil {
			return nil, err
		}
	}
	var queryData *sql.Rows
	if tx != nil {
		queryData, err = tx.Query(sqlstr, ipaddress)
		if err != nil {
			return nil, err
		}
	} else {
		queryData, err = dbConn.Query(sqlstr, ipaddress)
		if err != nil {
			return nil, err
		}
	}

	defer queryData.Close()

	// load results
	res := make([]*Syslog, 0)
	for queryData.Next() {
		s := Syslog{
			_exists: true,
		}

		// scan
		err = queryData.Scan(&s.ID, &s.Ipaddress, &s.URL, &s.Referer, &s.Adddt, &s.Guestcode, &s.Param, &s.Module, &s.Control, &s.UID, &s.Cid, &s.Gid, &s.Vid, &s.Iplocation, &s.Useragent, &s.Sagent, &s.Addtime)
		if err != nil {
			return nil, err
		}

		res = append(res, &s)
	}

	return res, nil
}

// SyslogsByModule retrieves a row from 'aypcddg.syslog' as a Syslog.
//
// Generated from index 'idx_module'.
func SyslogsByModule(ctx context.Context, module sql.NullString, key ...interface{}) ([]*Syslog, error) {
	var err error
	var dbConn *sql.DB

	tableName, err := GetSyslogTableName(key...)
	if err != nil {
		return nil, err
	}

	// sql query
	sqlstr := `SELECT ` +
		`id, ipaddress, url, referer, adddt, guestcode, param, module, control, uid, cid, gid, vid, iplocation, useragent, sagent, addtime ` +
		`FROM ` + tableName +
		` WHERE module = ?`

	// run query
	utils.GetTraceLog(ctx).Debug("DB", zap.String("SQL", fmt.Sprint(sqlstr, module)))

	tx, err := components.M.GetConnFromCtx(ctx)
	if err != nil {
		dbConn, err = components.M.GetSlaveConn()
		if err != nil {
			return nil, err
		}
	}
	var queryData *sql.Rows
	if tx != nil {
		queryData, err = tx.Query(sqlstr, module)
		if err != nil {
			return nil, err
		}
	} else {
		queryData, err = dbConn.Query(sqlstr, module)
		if err != nil {
			return nil, err
		}
	}

	defer queryData.Close()

	// load results
	res := make([]*Syslog, 0)
	for queryData.Next() {
		s := Syslog{
			_exists: true,
		}

		// scan
		err = queryData.Scan(&s.ID, &s.Ipaddress, &s.URL, &s.Referer, &s.Adddt, &s.Guestcode, &s.Param, &s.Module, &s.Control, &s.UID, &s.Cid, &s.Gid, &s.Vid, &s.Iplocation, &s.Useragent, &s.Sagent, &s.Addtime)
		if err != nil {
			return nil, err
		}

		res = append(res, &s)
	}

	return res, nil
}

// SyslogsBySagent retrieves a row from 'aypcddg.syslog' as a Syslog.
//
// Generated from index 'sagent'.
func SyslogsBySagent(ctx context.Context, sagent sql.NullString, key ...interface{}) ([]*Syslog, error) {
	var err error
	var dbConn *sql.DB

	tableName, err := GetSyslogTableName(key...)
	if err != nil {
		return nil, err
	}

	// sql query
	sqlstr := `SELECT ` +
		`id, ipaddress, url, referer, adddt, guestcode, param, module, control, uid, cid, gid, vid, iplocation, useragent, sagent, addtime ` +
		`FROM ` + tableName +
		` WHERE sagent = ?`

	// run query
	utils.GetTraceLog(ctx).Debug("DB", zap.String("SQL", fmt.Sprint(sqlstr, sagent)))

	tx, err := components.M.GetConnFromCtx(ctx)
	if err != nil {
		dbConn, err = components.M.GetSlaveConn()
		if err != nil {
			return nil, err
		}
	}
	var queryData *sql.Rows
	if tx != nil {
		queryData, err = tx.Query(sqlstr, sagent)
		if err != nil {
			return nil, err
		}
	} else {
		queryData, err = dbConn.Query(sqlstr, sagent)
		if err != nil {
			return nil, err
		}
	}

	defer queryData.Close()

	// load results
	res := make([]*Syslog, 0)
	for queryData.Next() {
		s := Syslog{
			_exists: true,
		}

		// scan
		err = queryData.Scan(&s.ID, &s.Ipaddress, &s.URL, &s.Referer, &s.Adddt, &s.Guestcode, &s.Param, &s.Module, &s.Control, &s.UID, &s.Cid, &s.Gid, &s.Vid, &s.Iplocation, &s.Useragent, &s.Sagent, &s.Addtime)
		if err != nil {
			return nil, err
		}

		res = append(res, &s)
	}

	return res, nil
}

// SyslogByID retrieves a row from 'aypcddg.syslog' as a Syslog.
//
// Generated from index 'syslog_id_pkey'.
func SyslogByID(ctx context.Context, id uint, key ...interface{}) (*Syslog, error) {
	var err error
	var dbConn *sql.DB

	tableName, err := GetSyslogTableName(key...)
	if err != nil {
		return nil, err
	}

	// sql query
	sqlstr := `SELECT ` +
		`id, ipaddress, url, referer, adddt, guestcode, param, module, control, uid, cid, gid, vid, iplocation, useragent, sagent, addtime ` +
		`FROM ` + tableName +
		` WHERE id = ?`

	// run query
	utils.GetTraceLog(ctx).Debug("DB", zap.String("SQL", fmt.Sprint(sqlstr, id)))

	tx, err := components.M.GetConnFromCtx(ctx)
	if err != nil {
		dbConn, err = components.M.GetSlaveConn()
		if err != nil {
			return nil, err
		}
	}
	s := Syslog{
		_exists: true,
	}

	if tx != nil {
		err = tx.QueryRow(sqlstr, id).Scan(&s.ID, &s.Ipaddress, &s.URL, &s.Referer, &s.Adddt, &s.Guestcode, &s.Param, &s.Module, &s.Control, &s.UID, &s.Cid, &s.Gid, &s.Vid, &s.Iplocation, &s.Useragent, &s.Sagent, &s.Addtime)
		if err != nil {
			return nil, err
		}
	} else {
		err = dbConn.QueryRow(sqlstr, id).Scan(&s.ID, &s.Ipaddress, &s.URL, &s.Referer, &s.Adddt, &s.Guestcode, &s.Param, &s.Module, &s.Control, &s.UID, &s.Cid, &s.Gid, &s.Vid, &s.Iplocation, &s.Useragent, &s.Sagent, &s.Addtime)
		if err != nil {
			return nil, err
		}
	}

	return &s, nil
}

// SyslogsByUID retrieves a row from 'aypcddg.syslog' as a Syslog.
//
// Generated from index 'uid'.
func SyslogsByUID(ctx context.Context, uid sql.NullInt64, key ...interface{}) ([]*Syslog, error) {
	var err error
	var dbConn *sql.DB

	tableName, err := GetSyslogTableName(key...)
	if err != nil {
		return nil, err
	}

	// sql query
	sqlstr := `SELECT ` +
		`id, ipaddress, url, referer, adddt, guestcode, param, module, control, uid, cid, gid, vid, iplocation, useragent, sagent, addtime ` +
		`FROM ` + tableName +
		` WHERE uid = ?`

	// run query
	utils.GetTraceLog(ctx).Debug("DB", zap.String("SQL", fmt.Sprint(sqlstr, uid)))

	tx, err := components.M.GetConnFromCtx(ctx)
	if err != nil {
		dbConn, err = components.M.GetSlaveConn()
		if err != nil {
			return nil, err
		}
	}
	var queryData *sql.Rows
	if tx != nil {
		queryData, err = tx.Query(sqlstr, uid)
		if err != nil {
			return nil, err
		}
	} else {
		queryData, err = dbConn.Query(sqlstr, uid)
		if err != nil {
			return nil, err
		}
	}

	defer queryData.Close()

	// load results
	res := make([]*Syslog, 0)
	for queryData.Next() {
		s := Syslog{
			_exists: true,
		}

		// scan
		err = queryData.Scan(&s.ID, &s.Ipaddress, &s.URL, &s.Referer, &s.Adddt, &s.Guestcode, &s.Param, &s.Module, &s.Control, &s.UID, &s.Cid, &s.Gid, &s.Vid, &s.Iplocation, &s.Useragent, &s.Sagent, &s.Addtime)
		if err != nil {
			return nil, err
		}

		res = append(res, &s)
	}

	return res, nil
}
