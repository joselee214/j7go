// Package xo contains the types for schema 'aypcddg'.
package xo

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	"j7go/components"
	"j7go/utils"

	"go.uber.org/zap"
)

// Good represents a row from 'aypcddg.goods'.
type Good struct {
	Gid                       uint64         `json:"gid"`                          // gid
	Pid                       int            `json:"pid"`                          // pid
	Title                     sql.NullString `json:"title"`                        // title
	AttributeGoodTitle        sql.NullString `json:"attribute_good_title"`         // attribute_good_title
	Fid                       uint64         `json:"fid"`                          // fid
	Fgid                      uint64         `json:"fgid"`                         // fgid
	Sid                       uint64         `json:"sid"`                          // sid
	Fbid                      uint           `json:"fbid"`                         // fbid
	Gcid                      uint           `json:"gcid"`                         // gcid
	Fcid                      uint           `json:"fcid"`                         // fcid
	Fpid                      uint64         `json:"fpid"`                         // fpid
	Status                    bool           `json:"status"`                       // status
	StatusChangeLastTimestamp uint           `json:"status_change_last_timestamp"` // status_change_last_timestamp
	FactoryOnly               bool           `json:"factory_only"`                 // factory_only
	PriceMode                 string         `json:"price_mode"`                   // price_mode
	Price                     float64        `json:"price"`                        // price
	PlanID                    int            `json:"plan_id"`                      // plan_id
	PlanIDStatus              int8           `json:"plan_id_status"`               // plan_id_status
	PlanNextID                int            `json:"plan_next_id"`                 // plan_next_id
	PlanNextTime              int            `json:"plan_next_time"`               // plan_next_time
	PlanNextPrice             float64        `json:"plan_next_price"`              // plan_next_price
	PlanNextIDStatus          int8           `json:"plan_next_id_status"`          // plan_next_id_status
	PrepayPrice               float64        `json:"prepay_price"`                 // prepay_price
	CanCod                    bool           `json:"can_cod"`                      // can_cod
	HasInvoice                bool           `json:"has_invoice"`                  // has_invoice
	Subtitle                  sql.NullString `json:"subtitle"`                     // subtitle
	Content                   sql.NullString `json:"content"`                      // content
	Packinfo                  sql.NullString `json:"packinfo"`                     // packinfo
	Weight                    float64        `json:"weight"`                       // weight
	Volume                    float64        `json:"volume"`                       // volume
	Sku                       sql.NullString `json:"sku"`                          // sku
	ProductCode               string         `json:"product_code"`                 // product_code
	BarCode                   string         `json:"bar_code"`                     // bar_code
	Stock                     uint           `json:"stock"`                        // stock
	FrozenStock               uint           `json:"frozen_stock"`                 // frozen_stock
	Stockday                  int16          `json:"stockday"`                     // stockday
	Unit                      sql.NullString `json:"unit"`                         // unit
	SoldNum                   int            `json:"sold_num"`                     // sold_num
	ListPicPath               sql.NullString `json:"list_pic_path"`                // list_pic_path
	ListPicPicids             string         `json:"list_pic_picids"`              // list_pic_picids
	Created                   uint           `json:"created"`                      // created
	Updated                   uint           `json:"updated"`                      // updated
	PlanUpTimestamp           uint           `json:"plan_up_timestamp"`            // plan_up_timestamp
	PlanDownTimestamp         uint           `json:"plan_down_timestamp"`          // plan_down_timestamp
	SeoKeyword                sql.NullString `json:"seo_keyword"`                  // seo_keyword
	SeoDescription            sql.NullString `json:"seo_description"`              // seo_description
	Fwid                      uint           `json:"fwid"`                         // fwid
	ShipID                    uint           `json:"ship_id"`                      // ship_id
	IsCheck                   int8           `json:"is_check"`                     // is_check
	ImageMode                 sql.NullString `json:"image_mode"`                   // image_mode
	MarketPrice               float64        `json:"market_price"`                 // market_price
	OtherImagePath            sql.NullString `json:"other_image_path"`             // other_image_path
	BrandTpID                 int64          `json:"brand_tp_id"`                  // brand_tp_id
	PackTpID                  int64          `json:"pack_tp_id"`                   // pack_tp_id
	DelegationTpID            int64          `json:"delegation_tp_id"`             // delegation_tp_id
	ServiceTpID               int64          `json:"service_tp_id"`                // service_tp_id
	ReportTpID                int64          `json:"report_tp_id"`                 // report_tp_id
	CustomContent             sql.NullString `json:"custom_content"`               // custom_content
	Visited                   int            `json:"visited"`                      // visited
	GoodsCommentNum           int            `json:"goods_comment_num"`            // goods_comment_num
	CategoryGlobalPathIds     sql.NullString `json:"category_global_path_ids"`     // category_global_path_ids
	AttributeValueIds         sql.NullString `json:"attribute_value_ids"`          // attribute_value_ids
	HelpMap                   string         `json:"help_map"`                     // help_map
	BrandID                   int            `json:"brand_id"`                     // brand_id
	ProfitPrice               float64        `json:"profit_price"`                 // profit_price

	// xo fields
	_exists, _deleted bool
}

// Exists determines if the Good exists in the database.
func (g *Good) Exists() bool { //goods
	return g._exists
}

// Deleted provides information if the Good has been deleted from the database.
func (g *Good) Deleted() bool {
	return g._deleted
}

// Get table name
func GetGoodTableName(key ...interface{}) (string, error) {
	tableName, err := components.M.GetTable("aypcddg", "goods", key...)
	if err != nil {
		return "", err
	}
	return tableName, nil
}

// Insert inserts the Good to the database.
func (g *Good) Insert(ctx context.Context, key ...interface{}) error {
	var err error
	var dbConn *sql.DB
	var res sql.Result
	// if already exist, bail
	if g._exists {
		return errors.New("insert failed: already exists")
	}

	tx, err := components.M.GetConnFromCtx(ctx)
	if err != nil {
		dbConn, err = components.M.GetMasterConn()
		if err != nil {
			return err
		}
	}

	tableName, err := GetGoodTableName(key...)
	if err != nil {
		return err
	}

	// sql insert query, primary key provided by autoincrement
	sqlstr := `INSERT INTO ` + tableName +
		` (` +
		`pid, title, attribute_good_title, fid, fgid, sid, fbid, gcid, fcid, fpid, status, status_change_last_timestamp, factory_only, price_mode, price, plan_id, plan_id_status, plan_next_id, plan_next_time, plan_next_price, plan_next_id_status, prepay_price, can_cod, has_invoice, subtitle, content, packinfo, weight, volume, sku, product_code, bar_code, stock, frozen_stock, stockday, unit, sold_num, list_pic_path, list_pic_picids, created, updated, plan_up_timestamp, plan_down_timestamp, seo_keyword, seo_description, fwid, ship_id, is_check, image_mode, market_price, other_image_path, brand_tp_id, pack_tp_id, delegation_tp_id, service_tp_id, report_tp_id, custom_content, visited, goods_comment_num, category_global_path_ids, attribute_value_ids, help_map, brand_id, profit_price` +
		`) VALUES (` +
		`?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?` +
		`)`

	// run query
	utils.GetTraceLog(ctx).Debug("DB", zap.String("SQL", fmt.Sprint(sqlstr, g.Pid, g.Title, g.AttributeGoodTitle, g.Fid, g.Fgid, g.Sid, g.Fbid, g.Gcid, g.Fcid, g.Fpid, g.Status, g.StatusChangeLastTimestamp, g.FactoryOnly, g.PriceMode, g.Price, g.PlanID, g.PlanIDStatus, g.PlanNextID, g.PlanNextTime, g.PlanNextPrice, g.PlanNextIDStatus, g.PrepayPrice, g.CanCod, g.HasInvoice, g.Subtitle, g.Content, g.Packinfo, g.Weight, g.Volume, g.Sku, g.ProductCode, g.BarCode, g.Stock, g.FrozenStock, g.Stockday, g.Unit, g.SoldNum, g.ListPicPath, g.ListPicPicids, g.Created, g.Updated, g.PlanUpTimestamp, g.PlanDownTimestamp, g.SeoKeyword, g.SeoDescription, g.Fwid, g.ShipID, g.IsCheck, g.ImageMode, g.MarketPrice, g.OtherImagePath, g.BrandTpID, g.PackTpID, g.DelegationTpID, g.ServiceTpID, g.ReportTpID, g.CustomContent, g.Visited, g.GoodsCommentNum, g.CategoryGlobalPathIds, g.AttributeValueIds, g.HelpMap, g.BrandID, g.ProfitPrice)))
	if err != nil {
		return err
	}
	if tx != nil {
		res, err = tx.Exec(sqlstr, g.Pid, g.Title, g.AttributeGoodTitle, g.Fid, g.Fgid, g.Sid, g.Fbid, g.Gcid, g.Fcid, g.Fpid, g.Status, g.StatusChangeLastTimestamp, g.FactoryOnly, g.PriceMode, g.Price, g.PlanID, g.PlanIDStatus, g.PlanNextID, g.PlanNextTime, g.PlanNextPrice, g.PlanNextIDStatus, g.PrepayPrice, g.CanCod, g.HasInvoice, g.Subtitle, g.Content, g.Packinfo, g.Weight, g.Volume, g.Sku, g.ProductCode, g.BarCode, g.Stock, g.FrozenStock, g.Stockday, g.Unit, g.SoldNum, g.ListPicPath, g.ListPicPicids, g.Created, g.Updated, g.PlanUpTimestamp, g.PlanDownTimestamp, g.SeoKeyword, g.SeoDescription, g.Fwid, g.ShipID, g.IsCheck, g.ImageMode, g.MarketPrice, g.OtherImagePath, g.BrandTpID, g.PackTpID, g.DelegationTpID, g.ServiceTpID, g.ReportTpID, g.CustomContent, g.Visited, g.GoodsCommentNum, g.CategoryGlobalPathIds, g.AttributeValueIds, g.HelpMap, g.BrandID, g.ProfitPrice)
	} else {
		res, err = dbConn.Exec(sqlstr, g.Pid, g.Title, g.AttributeGoodTitle, g.Fid, g.Fgid, g.Sid, g.Fbid, g.Gcid, g.Fcid, g.Fpid, g.Status, g.StatusChangeLastTimestamp, g.FactoryOnly, g.PriceMode, g.Price, g.PlanID, g.PlanIDStatus, g.PlanNextID, g.PlanNextTime, g.PlanNextPrice, g.PlanNextIDStatus, g.PrepayPrice, g.CanCod, g.HasInvoice, g.Subtitle, g.Content, g.Packinfo, g.Weight, g.Volume, g.Sku, g.ProductCode, g.BarCode, g.Stock, g.FrozenStock, g.Stockday, g.Unit, g.SoldNum, g.ListPicPath, g.ListPicPicids, g.Created, g.Updated, g.PlanUpTimestamp, g.PlanDownTimestamp, g.SeoKeyword, g.SeoDescription, g.Fwid, g.ShipID, g.IsCheck, g.ImageMode, g.MarketPrice, g.OtherImagePath, g.BrandTpID, g.PackTpID, g.DelegationTpID, g.ServiceTpID, g.ReportTpID, g.CustomContent, g.Visited, g.GoodsCommentNum, g.CategoryGlobalPathIds, g.AttributeValueIds, g.HelpMap, g.BrandID, g.ProfitPrice)
	}

	if err != nil {
		return err
	}

	// retrieve id
	id, err := res.LastInsertId()
	if err != nil {
		return err
	}

	// set primary key and existence
	g.Gid = uint64(id)
	g._exists = true

	return nil
}

// Update updates the Good in the database.
func (g *Good) Update(ctx context.Context, key ...interface{}) error {
	var err error
	var dbConn *sql.DB

	// if deleted, bail
	if g._deleted {
		return errors.New("update failed: marked for deletion")
	}

	tx, err := components.M.GetConnFromCtx(ctx)
	if err != nil {
		dbConn, err = components.M.GetMasterConn()
		if err != nil {
			return err
		}
	}

	tableName, err := GetGoodTableName(key...)
	if err != nil {
		return err
	}

	// sql query
	sqlstr := `UPDATE ` + tableName + ` SET ` +
		`pid = ?, title = ?, attribute_good_title = ?, fid = ?, fgid = ?, sid = ?, fbid = ?, gcid = ?, fcid = ?, fpid = ?, status = ?, status_change_last_timestamp = ?, factory_only = ?, price_mode = ?, price = ?, plan_id = ?, plan_id_status = ?, plan_next_id = ?, plan_next_time = ?, plan_next_price = ?, plan_next_id_status = ?, prepay_price = ?, can_cod = ?, has_invoice = ?, subtitle = ?, content = ?, packinfo = ?, weight = ?, volume = ?, sku = ?, product_code = ?, bar_code = ?, stock = ?, frozen_stock = ?, stockday = ?, unit = ?, sold_num = ?, list_pic_path = ?, list_pic_picids = ?, created = ?, updated = ?, plan_up_timestamp = ?, plan_down_timestamp = ?, seo_keyword = ?, seo_description = ?, fwid = ?, ship_id = ?, is_check = ?, image_mode = ?, market_price = ?, other_image_path = ?, brand_tp_id = ?, pack_tp_id = ?, delegation_tp_id = ?, service_tp_id = ?, report_tp_id = ?, custom_content = ?, visited = ?, goods_comment_num = ?, category_global_path_ids = ?, attribute_value_ids = ?, help_map = ?, brand_id = ?, profit_price = ?` +
		` WHERE gid = ?`

	// run query
	utils.GetTraceLog(ctx).Debug("DB", zap.String("SQL", fmt.Sprint(sqlstr, g.Pid, g.Title, g.AttributeGoodTitle, g.Fid, g.Fgid, g.Sid, g.Fbid, g.Gcid, g.Fcid, g.Fpid, g.Status, g.StatusChangeLastTimestamp, g.FactoryOnly, g.PriceMode, g.Price, g.PlanID, g.PlanIDStatus, g.PlanNextID, g.PlanNextTime, g.PlanNextPrice, g.PlanNextIDStatus, g.PrepayPrice, g.CanCod, g.HasInvoice, g.Subtitle, g.Content, g.Packinfo, g.Weight, g.Volume, g.Sku, g.ProductCode, g.BarCode, g.Stock, g.FrozenStock, g.Stockday, g.Unit, g.SoldNum, g.ListPicPath, g.ListPicPicids, g.Created, g.Updated, g.PlanUpTimestamp, g.PlanDownTimestamp, g.SeoKeyword, g.SeoDescription, g.Fwid, g.ShipID, g.IsCheck, g.ImageMode, g.MarketPrice, g.OtherImagePath, g.BrandTpID, g.PackTpID, g.DelegationTpID, g.ServiceTpID, g.ReportTpID, g.CustomContent, g.Visited, g.GoodsCommentNum, g.CategoryGlobalPathIds, g.AttributeValueIds, g.HelpMap, g.BrandID, g.ProfitPrice, g.Gid)))
	if tx != nil {
		_, err = tx.Exec(sqlstr, g.Pid, g.Title, g.AttributeGoodTitle, g.Fid, g.Fgid, g.Sid, g.Fbid, g.Gcid, g.Fcid, g.Fpid, g.Status, g.StatusChangeLastTimestamp, g.FactoryOnly, g.PriceMode, g.Price, g.PlanID, g.PlanIDStatus, g.PlanNextID, g.PlanNextTime, g.PlanNextPrice, g.PlanNextIDStatus, g.PrepayPrice, g.CanCod, g.HasInvoice, g.Subtitle, g.Content, g.Packinfo, g.Weight, g.Volume, g.Sku, g.ProductCode, g.BarCode, g.Stock, g.FrozenStock, g.Stockday, g.Unit, g.SoldNum, g.ListPicPath, g.ListPicPicids, g.Created, g.Updated, g.PlanUpTimestamp, g.PlanDownTimestamp, g.SeoKeyword, g.SeoDescription, g.Fwid, g.ShipID, g.IsCheck, g.ImageMode, g.MarketPrice, g.OtherImagePath, g.BrandTpID, g.PackTpID, g.DelegationTpID, g.ServiceTpID, g.ReportTpID, g.CustomContent, g.Visited, g.GoodsCommentNum, g.CategoryGlobalPathIds, g.AttributeValueIds, g.HelpMap, g.BrandID, g.ProfitPrice, g.Gid)
	} else {
		_, err = dbConn.Exec(sqlstr, g.Pid, g.Title, g.AttributeGoodTitle, g.Fid, g.Fgid, g.Sid, g.Fbid, g.Gcid, g.Fcid, g.Fpid, g.Status, g.StatusChangeLastTimestamp, g.FactoryOnly, g.PriceMode, g.Price, g.PlanID, g.PlanIDStatus, g.PlanNextID, g.PlanNextTime, g.PlanNextPrice, g.PlanNextIDStatus, g.PrepayPrice, g.CanCod, g.HasInvoice, g.Subtitle, g.Content, g.Packinfo, g.Weight, g.Volume, g.Sku, g.ProductCode, g.BarCode, g.Stock, g.FrozenStock, g.Stockday, g.Unit, g.SoldNum, g.ListPicPath, g.ListPicPicids, g.Created, g.Updated, g.PlanUpTimestamp, g.PlanDownTimestamp, g.SeoKeyword, g.SeoDescription, g.Fwid, g.ShipID, g.IsCheck, g.ImageMode, g.MarketPrice, g.OtherImagePath, g.BrandTpID, g.PackTpID, g.DelegationTpID, g.ServiceTpID, g.ReportTpID, g.CustomContent, g.Visited, g.GoodsCommentNum, g.CategoryGlobalPathIds, g.AttributeValueIds, g.HelpMap, g.BrandID, g.ProfitPrice, g.Gid)
	}
	return err
}

// Save saves the Good to the database.
func (g *Good) Save(ctx context.Context) error {
	if g.Exists() {
		return g.Update(ctx)
	}

	return g.Insert(ctx)
}

// Delete deletes the Good from the database.
func (g *Good) Delete(ctx context.Context, key ...interface{}) error {
	var err error
	var dbConn *sql.DB

	// if deleted, bail
	if g._deleted {
		return nil
	}

	tx, err := components.M.GetConnFromCtx(ctx)
	if err != nil {
		dbConn, err = components.M.GetMasterConn()
		if err != nil {
			return err
		}
	}

	tableName, err := GetGoodTableName(key...)
	if err != nil {
		return err
	}
	//1

	// sql query with composite primary key
	sqlstr := `UPDATE ` + tableName + ` SET is_del = 1 WHERE gid = ?`

	// run query
	utils.GetTraceLog(ctx).Debug("DB", zap.String("SQL", fmt.Sprint(sqlstr, g.Gid)))
	if tx != nil {
		_, err = tx.Exec(sqlstr, g.Gid)
	} else {
		_, err = dbConn.Exec(sqlstr, g.Gid)
	}

	if err != nil {
		return err
	}

	// set deleted
	g._deleted = true

	return nil
}

// GoodsByCanCod retrieves a row from 'aypcddg.goods' as a Good.
//
// Generated from index 'can_cod'.
func GoodsByCanCod(ctx context.Context, canCod bool, key ...interface{}) ([]*Good, error) {
	var err error
	var dbConn *sql.DB

	tableName, err := GetGoodTableName(key...)
	if err != nil {
		return nil, err
	}

	// sql query
	sqlstr := `SELECT ` +
		`gid, pid, title, attribute_good_title, fid, fgid, sid, fbid, gcid, fcid, fpid, status, status_change_last_timestamp, factory_only, price_mode, price, plan_id, plan_id_status, plan_next_id, plan_next_time, plan_next_price, plan_next_id_status, prepay_price, can_cod, has_invoice, subtitle, content, packinfo, weight, volume, sku, product_code, bar_code, stock, frozen_stock, stockday, unit, sold_num, list_pic_path, list_pic_picids, created, updated, plan_up_timestamp, plan_down_timestamp, seo_keyword, seo_description, fwid, ship_id, is_check, image_mode, market_price, other_image_path, brand_tp_id, pack_tp_id, delegation_tp_id, service_tp_id, report_tp_id, custom_content, visited, goods_comment_num, category_global_path_ids, attribute_value_ids, help_map, brand_id, profit_price ` +
		`FROM ` + tableName +
		` WHERE can_cod = ?`

	// run query
	utils.GetTraceLog(ctx).Debug("DB", zap.String("SQL", fmt.Sprint(sqlstr, canCod)))

	tx, err := components.M.GetConnFromCtx(ctx)
	if err != nil {
		dbConn, err = components.M.GetSlaveConn()
		if err != nil {
			return nil, err
		}
	}
	var queryData *sql.Rows
	if tx != nil {
		queryData, err = tx.Query(sqlstr, canCod)
		if err != nil {
			return nil, err
		}
	} else {
		queryData, err = dbConn.Query(sqlstr, canCod)
		if err != nil {
			return nil, err
		}
	}

	defer queryData.Close()

	// load results
	res := make([]*Good, 0)
	for queryData.Next() {
		g := Good{
			_exists: true,
		}

		// scan
		err = queryData.Scan(&g.Gid, &g.Pid, &g.Title, &g.AttributeGoodTitle, &g.Fid, &g.Fgid, &g.Sid, &g.Fbid, &g.Gcid, &g.Fcid, &g.Fpid, &g.Status, &g.StatusChangeLastTimestamp, &g.FactoryOnly, &g.PriceMode, &g.Price, &g.PlanID, &g.PlanIDStatus, &g.PlanNextID, &g.PlanNextTime, &g.PlanNextPrice, &g.PlanNextIDStatus, &g.PrepayPrice, &g.CanCod, &g.HasInvoice, &g.Subtitle, &g.Content, &g.Packinfo, &g.Weight, &g.Volume, &g.Sku, &g.ProductCode, &g.BarCode, &g.Stock, &g.FrozenStock, &g.Stockday, &g.Unit, &g.SoldNum, &g.ListPicPath, &g.ListPicPicids, &g.Created, &g.Updated, &g.PlanUpTimestamp, &g.PlanDownTimestamp, &g.SeoKeyword, &g.SeoDescription, &g.Fwid, &g.ShipID, &g.IsCheck, &g.ImageMode, &g.MarketPrice, &g.OtherImagePath, &g.BrandTpID, &g.PackTpID, &g.DelegationTpID, &g.ServiceTpID, &g.ReportTpID, &g.CustomContent, &g.Visited, &g.GoodsCommentNum, &g.CategoryGlobalPathIds, &g.AttributeValueIds, &g.HelpMap, &g.BrandID, &g.ProfitPrice)
		if err != nil {
			return nil, err
		}

		res = append(res, &g)
	}

	return res, nil
}

// GoodsByPlanDownTimestamp retrieves a row from 'aypcddg.goods' as a Good.
//
// Generated from index 'down_stock'.
func GoodsByPlanDownTimestamp(ctx context.Context, planDownTimestamp uint, key ...interface{}) ([]*Good, error) {
	var err error
	var dbConn *sql.DB

	tableName, err := GetGoodTableName(key...)
	if err != nil {
		return nil, err
	}

	// sql query
	sqlstr := `SELECT ` +
		`gid, pid, title, attribute_good_title, fid, fgid, sid, fbid, gcid, fcid, fpid, status, status_change_last_timestamp, factory_only, price_mode, price, plan_id, plan_id_status, plan_next_id, plan_next_time, plan_next_price, plan_next_id_status, prepay_price, can_cod, has_invoice, subtitle, content, packinfo, weight, volume, sku, product_code, bar_code, stock, frozen_stock, stockday, unit, sold_num, list_pic_path, list_pic_picids, created, updated, plan_up_timestamp, plan_down_timestamp, seo_keyword, seo_description, fwid, ship_id, is_check, image_mode, market_price, other_image_path, brand_tp_id, pack_tp_id, delegation_tp_id, service_tp_id, report_tp_id, custom_content, visited, goods_comment_num, category_global_path_ids, attribute_value_ids, help_map, brand_id, profit_price ` +
		`FROM ` + tableName +
		` WHERE plan_down_timestamp = ?`

	// run query
	utils.GetTraceLog(ctx).Debug("DB", zap.String("SQL", fmt.Sprint(sqlstr, planDownTimestamp)))

	tx, err := components.M.GetConnFromCtx(ctx)
	if err != nil {
		dbConn, err = components.M.GetSlaveConn()
		if err != nil {
			return nil, err
		}
	}
	var queryData *sql.Rows
	if tx != nil {
		queryData, err = tx.Query(sqlstr, planDownTimestamp)
		if err != nil {
			return nil, err
		}
	} else {
		queryData, err = dbConn.Query(sqlstr, planDownTimestamp)
		if err != nil {
			return nil, err
		}
	}

	defer queryData.Close()

	// load results
	res := make([]*Good, 0)
	for queryData.Next() {
		g := Good{
			_exists: true,
		}

		// scan
		err = queryData.Scan(&g.Gid, &g.Pid, &g.Title, &g.AttributeGoodTitle, &g.Fid, &g.Fgid, &g.Sid, &g.Fbid, &g.Gcid, &g.Fcid, &g.Fpid, &g.Status, &g.StatusChangeLastTimestamp, &g.FactoryOnly, &g.PriceMode, &g.Price, &g.PlanID, &g.PlanIDStatus, &g.PlanNextID, &g.PlanNextTime, &g.PlanNextPrice, &g.PlanNextIDStatus, &g.PrepayPrice, &g.CanCod, &g.HasInvoice, &g.Subtitle, &g.Content, &g.Packinfo, &g.Weight, &g.Volume, &g.Sku, &g.ProductCode, &g.BarCode, &g.Stock, &g.FrozenStock, &g.Stockday, &g.Unit, &g.SoldNum, &g.ListPicPath, &g.ListPicPicids, &g.Created, &g.Updated, &g.PlanUpTimestamp, &g.PlanDownTimestamp, &g.SeoKeyword, &g.SeoDescription, &g.Fwid, &g.ShipID, &g.IsCheck, &g.ImageMode, &g.MarketPrice, &g.OtherImagePath, &g.BrandTpID, &g.PackTpID, &g.DelegationTpID, &g.ServiceTpID, &g.ReportTpID, &g.CustomContent, &g.Visited, &g.GoodsCommentNum, &g.CategoryGlobalPathIds, &g.AttributeValueIds, &g.HelpMap, &g.BrandID, &g.ProfitPrice)
		if err != nil {
			return nil, err
		}

		res = append(res, &g)
	}

	return res, nil
}

// GoodsByFcid retrieves a row from 'aypcddg.goods' as a Good.
//
// Generated from index 'fcid'.
func GoodsByFcid(ctx context.Context, fcid uint, key ...interface{}) ([]*Good, error) {
	var err error
	var dbConn *sql.DB

	tableName, err := GetGoodTableName(key...)
	if err != nil {
		return nil, err
	}

	// sql query
	sqlstr := `SELECT ` +
		`gid, pid, title, attribute_good_title, fid, fgid, sid, fbid, gcid, fcid, fpid, status, status_change_last_timestamp, factory_only, price_mode, price, plan_id, plan_id_status, plan_next_id, plan_next_time, plan_next_price, plan_next_id_status, prepay_price, can_cod, has_invoice, subtitle, content, packinfo, weight, volume, sku, product_code, bar_code, stock, frozen_stock, stockday, unit, sold_num, list_pic_path, list_pic_picids, created, updated, plan_up_timestamp, plan_down_timestamp, seo_keyword, seo_description, fwid, ship_id, is_check, image_mode, market_price, other_image_path, brand_tp_id, pack_tp_id, delegation_tp_id, service_tp_id, report_tp_id, custom_content, visited, goods_comment_num, category_global_path_ids, attribute_value_ids, help_map, brand_id, profit_price ` +
		`FROM ` + tableName +
		` WHERE fcid = ?`

	// run query
	utils.GetTraceLog(ctx).Debug("DB", zap.String("SQL", fmt.Sprint(sqlstr, fcid)))

	tx, err := components.M.GetConnFromCtx(ctx)
	if err != nil {
		dbConn, err = components.M.GetSlaveConn()
		if err != nil {
			return nil, err
		}
	}
	var queryData *sql.Rows
	if tx != nil {
		queryData, err = tx.Query(sqlstr, fcid)
		if err != nil {
			return nil, err
		}
	} else {
		queryData, err = dbConn.Query(sqlstr, fcid)
		if err != nil {
			return nil, err
		}
	}

	defer queryData.Close()

	// load results
	res := make([]*Good, 0)
	for queryData.Next() {
		g := Good{
			_exists: true,
		}

		// scan
		err = queryData.Scan(&g.Gid, &g.Pid, &g.Title, &g.AttributeGoodTitle, &g.Fid, &g.Fgid, &g.Sid, &g.Fbid, &g.Gcid, &g.Fcid, &g.Fpid, &g.Status, &g.StatusChangeLastTimestamp, &g.FactoryOnly, &g.PriceMode, &g.Price, &g.PlanID, &g.PlanIDStatus, &g.PlanNextID, &g.PlanNextTime, &g.PlanNextPrice, &g.PlanNextIDStatus, &g.PrepayPrice, &g.CanCod, &g.HasInvoice, &g.Subtitle, &g.Content, &g.Packinfo, &g.Weight, &g.Volume, &g.Sku, &g.ProductCode, &g.BarCode, &g.Stock, &g.FrozenStock, &g.Stockday, &g.Unit, &g.SoldNum, &g.ListPicPath, &g.ListPicPicids, &g.Created, &g.Updated, &g.PlanUpTimestamp, &g.PlanDownTimestamp, &g.SeoKeyword, &g.SeoDescription, &g.Fwid, &g.ShipID, &g.IsCheck, &g.ImageMode, &g.MarketPrice, &g.OtherImagePath, &g.BrandTpID, &g.PackTpID, &g.DelegationTpID, &g.ServiceTpID, &g.ReportTpID, &g.CustomContent, &g.Visited, &g.GoodsCommentNum, &g.CategoryGlobalPathIds, &g.AttributeValueIds, &g.HelpMap, &g.BrandID, &g.ProfitPrice)
		if err != nil {
			return nil, err
		}

		res = append(res, &g)
	}

	return res, nil
}

// GoodsByFgid retrieves a row from 'aypcddg.goods' as a Good.
//
// Generated from index 'fgid'.
func GoodsByFgid(ctx context.Context, fgid uint64, key ...interface{}) ([]*Good, error) {
	var err error
	var dbConn *sql.DB

	tableName, err := GetGoodTableName(key...)
	if err != nil {
		return nil, err
	}

	// sql query
	sqlstr := `SELECT ` +
		`gid, pid, title, attribute_good_title, fid, fgid, sid, fbid, gcid, fcid, fpid, status, status_change_last_timestamp, factory_only, price_mode, price, plan_id, plan_id_status, plan_next_id, plan_next_time, plan_next_price, plan_next_id_status, prepay_price, can_cod, has_invoice, subtitle, content, packinfo, weight, volume, sku, product_code, bar_code, stock, frozen_stock, stockday, unit, sold_num, list_pic_path, list_pic_picids, created, updated, plan_up_timestamp, plan_down_timestamp, seo_keyword, seo_description, fwid, ship_id, is_check, image_mode, market_price, other_image_path, brand_tp_id, pack_tp_id, delegation_tp_id, service_tp_id, report_tp_id, custom_content, visited, goods_comment_num, category_global_path_ids, attribute_value_ids, help_map, brand_id, profit_price ` +
		`FROM ` + tableName +
		` WHERE fgid = ?`

	// run query
	utils.GetTraceLog(ctx).Debug("DB", zap.String("SQL", fmt.Sprint(sqlstr, fgid)))

	tx, err := components.M.GetConnFromCtx(ctx)
	if err != nil {
		dbConn, err = components.M.GetSlaveConn()
		if err != nil {
			return nil, err
		}
	}
	var queryData *sql.Rows
	if tx != nil {
		queryData, err = tx.Query(sqlstr, fgid)
		if err != nil {
			return nil, err
		}
	} else {
		queryData, err = dbConn.Query(sqlstr, fgid)
		if err != nil {
			return nil, err
		}
	}

	defer queryData.Close()

	// load results
	res := make([]*Good, 0)
	for queryData.Next() {
		g := Good{
			_exists: true,
		}

		// scan
		err = queryData.Scan(&g.Gid, &g.Pid, &g.Title, &g.AttributeGoodTitle, &g.Fid, &g.Fgid, &g.Sid, &g.Fbid, &g.Gcid, &g.Fcid, &g.Fpid, &g.Status, &g.StatusChangeLastTimestamp, &g.FactoryOnly, &g.PriceMode, &g.Price, &g.PlanID, &g.PlanIDStatus, &g.PlanNextID, &g.PlanNextTime, &g.PlanNextPrice, &g.PlanNextIDStatus, &g.PrepayPrice, &g.CanCod, &g.HasInvoice, &g.Subtitle, &g.Content, &g.Packinfo, &g.Weight, &g.Volume, &g.Sku, &g.ProductCode, &g.BarCode, &g.Stock, &g.FrozenStock, &g.Stockday, &g.Unit, &g.SoldNum, &g.ListPicPath, &g.ListPicPicids, &g.Created, &g.Updated, &g.PlanUpTimestamp, &g.PlanDownTimestamp, &g.SeoKeyword, &g.SeoDescription, &g.Fwid, &g.ShipID, &g.IsCheck, &g.ImageMode, &g.MarketPrice, &g.OtherImagePath, &g.BrandTpID, &g.PackTpID, &g.DelegationTpID, &g.ServiceTpID, &g.ReportTpID, &g.CustomContent, &g.Visited, &g.GoodsCommentNum, &g.CategoryGlobalPathIds, &g.AttributeValueIds, &g.HelpMap, &g.BrandID, &g.ProfitPrice)
		if err != nil {
			return nil, err
		}

		res = append(res, &g)
	}

	return res, nil
}

// GoodsByFid retrieves a row from 'aypcddg.goods' as a Good.
//
// Generated from index 'fid'.
func GoodsByFid(ctx context.Context, fid uint64, key ...interface{}) ([]*Good, error) {
	var err error
	var dbConn *sql.DB

	tableName, err := GetGoodTableName(key...)
	if err != nil {
		return nil, err
	}

	// sql query
	sqlstr := `SELECT ` +
		`gid, pid, title, attribute_good_title, fid, fgid, sid, fbid, gcid, fcid, fpid, status, status_change_last_timestamp, factory_only, price_mode, price, plan_id, plan_id_status, plan_next_id, plan_next_time, plan_next_price, plan_next_id_status, prepay_price, can_cod, has_invoice, subtitle, content, packinfo, weight, volume, sku, product_code, bar_code, stock, frozen_stock, stockday, unit, sold_num, list_pic_path, list_pic_picids, created, updated, plan_up_timestamp, plan_down_timestamp, seo_keyword, seo_description, fwid, ship_id, is_check, image_mode, market_price, other_image_path, brand_tp_id, pack_tp_id, delegation_tp_id, service_tp_id, report_tp_id, custom_content, visited, goods_comment_num, category_global_path_ids, attribute_value_ids, help_map, brand_id, profit_price ` +
		`FROM ` + tableName +
		` WHERE fid = ?`

	// run query
	utils.GetTraceLog(ctx).Debug("DB", zap.String("SQL", fmt.Sprint(sqlstr, fid)))

	tx, err := components.M.GetConnFromCtx(ctx)
	if err != nil {
		dbConn, err = components.M.GetSlaveConn()
		if err != nil {
			return nil, err
		}
	}
	var queryData *sql.Rows
	if tx != nil {
		queryData, err = tx.Query(sqlstr, fid)
		if err != nil {
			return nil, err
		}
	} else {
		queryData, err = dbConn.Query(sqlstr, fid)
		if err != nil {
			return nil, err
		}
	}

	defer queryData.Close()

	// load results
	res := make([]*Good, 0)
	for queryData.Next() {
		g := Good{
			_exists: true,
		}

		// scan
		err = queryData.Scan(&g.Gid, &g.Pid, &g.Title, &g.AttributeGoodTitle, &g.Fid, &g.Fgid, &g.Sid, &g.Fbid, &g.Gcid, &g.Fcid, &g.Fpid, &g.Status, &g.StatusChangeLastTimestamp, &g.FactoryOnly, &g.PriceMode, &g.Price, &g.PlanID, &g.PlanIDStatus, &g.PlanNextID, &g.PlanNextTime, &g.PlanNextPrice, &g.PlanNextIDStatus, &g.PrepayPrice, &g.CanCod, &g.HasInvoice, &g.Subtitle, &g.Content, &g.Packinfo, &g.Weight, &g.Volume, &g.Sku, &g.ProductCode, &g.BarCode, &g.Stock, &g.FrozenStock, &g.Stockday, &g.Unit, &g.SoldNum, &g.ListPicPath, &g.ListPicPicids, &g.Created, &g.Updated, &g.PlanUpTimestamp, &g.PlanDownTimestamp, &g.SeoKeyword, &g.SeoDescription, &g.Fwid, &g.ShipID, &g.IsCheck, &g.ImageMode, &g.MarketPrice, &g.OtherImagePath, &g.BrandTpID, &g.PackTpID, &g.DelegationTpID, &g.ServiceTpID, &g.ReportTpID, &g.CustomContent, &g.Visited, &g.GoodsCommentNum, &g.CategoryGlobalPathIds, &g.AttributeValueIds, &g.HelpMap, &g.BrandID, &g.ProfitPrice)
		if err != nil {
			return nil, err
		}

		res = append(res, &g)
	}

	return res, nil
}

// GoodsBySid retrieves a row from 'aypcddg.goods' as a Good.
//
// Generated from index 'fsid'.
func GoodsBySid(ctx context.Context, sid uint64, key ...interface{}) ([]*Good, error) {
	var err error
	var dbConn *sql.DB

	tableName, err := GetGoodTableName(key...)
	if err != nil {
		return nil, err
	}

	// sql query
	sqlstr := `SELECT ` +
		`gid, pid, title, attribute_good_title, fid, fgid, sid, fbid, gcid, fcid, fpid, status, status_change_last_timestamp, factory_only, price_mode, price, plan_id, plan_id_status, plan_next_id, plan_next_time, plan_next_price, plan_next_id_status, prepay_price, can_cod, has_invoice, subtitle, content, packinfo, weight, volume, sku, product_code, bar_code, stock, frozen_stock, stockday, unit, sold_num, list_pic_path, list_pic_picids, created, updated, plan_up_timestamp, plan_down_timestamp, seo_keyword, seo_description, fwid, ship_id, is_check, image_mode, market_price, other_image_path, brand_tp_id, pack_tp_id, delegation_tp_id, service_tp_id, report_tp_id, custom_content, visited, goods_comment_num, category_global_path_ids, attribute_value_ids, help_map, brand_id, profit_price ` +
		`FROM ` + tableName +
		` WHERE sid = ?`

	// run query
	utils.GetTraceLog(ctx).Debug("DB", zap.String("SQL", fmt.Sprint(sqlstr, sid)))

	tx, err := components.M.GetConnFromCtx(ctx)
	if err != nil {
		dbConn, err = components.M.GetSlaveConn()
		if err != nil {
			return nil, err
		}
	}
	var queryData *sql.Rows
	if tx != nil {
		queryData, err = tx.Query(sqlstr, sid)
		if err != nil {
			return nil, err
		}
	} else {
		queryData, err = dbConn.Query(sqlstr, sid)
		if err != nil {
			return nil, err
		}
	}

	defer queryData.Close()

	// load results
	res := make([]*Good, 0)
	for queryData.Next() {
		g := Good{
			_exists: true,
		}

		// scan
		err = queryData.Scan(&g.Gid, &g.Pid, &g.Title, &g.AttributeGoodTitle, &g.Fid, &g.Fgid, &g.Sid, &g.Fbid, &g.Gcid, &g.Fcid, &g.Fpid, &g.Status, &g.StatusChangeLastTimestamp, &g.FactoryOnly, &g.PriceMode, &g.Price, &g.PlanID, &g.PlanIDStatus, &g.PlanNextID, &g.PlanNextTime, &g.PlanNextPrice, &g.PlanNextIDStatus, &g.PrepayPrice, &g.CanCod, &g.HasInvoice, &g.Subtitle, &g.Content, &g.Packinfo, &g.Weight, &g.Volume, &g.Sku, &g.ProductCode, &g.BarCode, &g.Stock, &g.FrozenStock, &g.Stockday, &g.Unit, &g.SoldNum, &g.ListPicPath, &g.ListPicPicids, &g.Created, &g.Updated, &g.PlanUpTimestamp, &g.PlanDownTimestamp, &g.SeoKeyword, &g.SeoDescription, &g.Fwid, &g.ShipID, &g.IsCheck, &g.ImageMode, &g.MarketPrice, &g.OtherImagePath, &g.BrandTpID, &g.PackTpID, &g.DelegationTpID, &g.ServiceTpID, &g.ReportTpID, &g.CustomContent, &g.Visited, &g.GoodsCommentNum, &g.CategoryGlobalPathIds, &g.AttributeValueIds, &g.HelpMap, &g.BrandID, &g.ProfitPrice)
		if err != nil {
			return nil, err
		}

		res = append(res, &g)
	}

	return res, nil
}

// GoodsByGcid retrieves a row from 'aypcddg.goods' as a Good.
//
// Generated from index 'gcid'.
func GoodsByGcid(ctx context.Context, gcid uint, key ...interface{}) ([]*Good, error) {
	var err error
	var dbConn *sql.DB

	tableName, err := GetGoodTableName(key...)
	if err != nil {
		return nil, err
	}

	// sql query
	sqlstr := `SELECT ` +
		`gid, pid, title, attribute_good_title, fid, fgid, sid, fbid, gcid, fcid, fpid, status, status_change_last_timestamp, factory_only, price_mode, price, plan_id, plan_id_status, plan_next_id, plan_next_time, plan_next_price, plan_next_id_status, prepay_price, can_cod, has_invoice, subtitle, content, packinfo, weight, volume, sku, product_code, bar_code, stock, frozen_stock, stockday, unit, sold_num, list_pic_path, list_pic_picids, created, updated, plan_up_timestamp, plan_down_timestamp, seo_keyword, seo_description, fwid, ship_id, is_check, image_mode, market_price, other_image_path, brand_tp_id, pack_tp_id, delegation_tp_id, service_tp_id, report_tp_id, custom_content, visited, goods_comment_num, category_global_path_ids, attribute_value_ids, help_map, brand_id, profit_price ` +
		`FROM ` + tableName +
		` WHERE gcid = ?`

	// run query
	utils.GetTraceLog(ctx).Debug("DB", zap.String("SQL", fmt.Sprint(sqlstr, gcid)))

	tx, err := components.M.GetConnFromCtx(ctx)
	if err != nil {
		dbConn, err = components.M.GetSlaveConn()
		if err != nil {
			return nil, err
		}
	}
	var queryData *sql.Rows
	if tx != nil {
		queryData, err = tx.Query(sqlstr, gcid)
		if err != nil {
			return nil, err
		}
	} else {
		queryData, err = dbConn.Query(sqlstr, gcid)
		if err != nil {
			return nil, err
		}
	}

	defer queryData.Close()

	// load results
	res := make([]*Good, 0)
	for queryData.Next() {
		g := Good{
			_exists: true,
		}

		// scan
		err = queryData.Scan(&g.Gid, &g.Pid, &g.Title, &g.AttributeGoodTitle, &g.Fid, &g.Fgid, &g.Sid, &g.Fbid, &g.Gcid, &g.Fcid, &g.Fpid, &g.Status, &g.StatusChangeLastTimestamp, &g.FactoryOnly, &g.PriceMode, &g.Price, &g.PlanID, &g.PlanIDStatus, &g.PlanNextID, &g.PlanNextTime, &g.PlanNextPrice, &g.PlanNextIDStatus, &g.PrepayPrice, &g.CanCod, &g.HasInvoice, &g.Subtitle, &g.Content, &g.Packinfo, &g.Weight, &g.Volume, &g.Sku, &g.ProductCode, &g.BarCode, &g.Stock, &g.FrozenStock, &g.Stockday, &g.Unit, &g.SoldNum, &g.ListPicPath, &g.ListPicPicids, &g.Created, &g.Updated, &g.PlanUpTimestamp, &g.PlanDownTimestamp, &g.SeoKeyword, &g.SeoDescription, &g.Fwid, &g.ShipID, &g.IsCheck, &g.ImageMode, &g.MarketPrice, &g.OtherImagePath, &g.BrandTpID, &g.PackTpID, &g.DelegationTpID, &g.ServiceTpID, &g.ReportTpID, &g.CustomContent, &g.Visited, &g.GoodsCommentNum, &g.CategoryGlobalPathIds, &g.AttributeValueIds, &g.HelpMap, &g.BrandID, &g.ProfitPrice)
		if err != nil {
			return nil, err
		}

		res = append(res, &g)
	}

	return res, nil
}

// GoodByGid retrieves a row from 'aypcddg.goods' as a Good.
//
// Generated from index 'goods_gid_pkey'.
func GoodByGid(ctx context.Context, gid uint64, key ...interface{}) (*Good, error) {
	var err error
	var dbConn *sql.DB

	tableName, err := GetGoodTableName(key...)
	if err != nil {
		return nil, err
	}

	// sql query
	sqlstr := `SELECT ` +
		`gid, pid, title, attribute_good_title, fid, fgid, sid, fbid, gcid, fcid, fpid, status, status_change_last_timestamp, factory_only, price_mode, price, plan_id, plan_id_status, plan_next_id, plan_next_time, plan_next_price, plan_next_id_status, prepay_price, can_cod, has_invoice, subtitle, content, packinfo, weight, volume, sku, product_code, bar_code, stock, frozen_stock, stockday, unit, sold_num, list_pic_path, list_pic_picids, created, updated, plan_up_timestamp, plan_down_timestamp, seo_keyword, seo_description, fwid, ship_id, is_check, image_mode, market_price, other_image_path, brand_tp_id, pack_tp_id, delegation_tp_id, service_tp_id, report_tp_id, custom_content, visited, goods_comment_num, category_global_path_ids, attribute_value_ids, help_map, brand_id, profit_price ` +
		`FROM ` + tableName +
		` WHERE gid = ?`

	// run query
	utils.GetTraceLog(ctx).Debug("DB", zap.String("SQL", fmt.Sprint(sqlstr, gid)))

	tx, err := components.M.GetConnFromCtx(ctx)
	if err != nil {
		dbConn, err = components.M.GetSlaveConn()
		if err != nil {
			return nil, err
		}
	}
	g := Good{
		_exists: true,
	}

	if tx != nil {
		err = tx.QueryRow(sqlstr, gid).Scan(&g.Gid, &g.Pid, &g.Title, &g.AttributeGoodTitle, &g.Fid, &g.Fgid, &g.Sid, &g.Fbid, &g.Gcid, &g.Fcid, &g.Fpid, &g.Status, &g.StatusChangeLastTimestamp, &g.FactoryOnly, &g.PriceMode, &g.Price, &g.PlanID, &g.PlanIDStatus, &g.PlanNextID, &g.PlanNextTime, &g.PlanNextPrice, &g.PlanNextIDStatus, &g.PrepayPrice, &g.CanCod, &g.HasInvoice, &g.Subtitle, &g.Content, &g.Packinfo, &g.Weight, &g.Volume, &g.Sku, &g.ProductCode, &g.BarCode, &g.Stock, &g.FrozenStock, &g.Stockday, &g.Unit, &g.SoldNum, &g.ListPicPath, &g.ListPicPicids, &g.Created, &g.Updated, &g.PlanUpTimestamp, &g.PlanDownTimestamp, &g.SeoKeyword, &g.SeoDescription, &g.Fwid, &g.ShipID, &g.IsCheck, &g.ImageMode, &g.MarketPrice, &g.OtherImagePath, &g.BrandTpID, &g.PackTpID, &g.DelegationTpID, &g.ServiceTpID, &g.ReportTpID, &g.CustomContent, &g.Visited, &g.GoodsCommentNum, &g.CategoryGlobalPathIds, &g.AttributeValueIds, &g.HelpMap, &g.BrandID, &g.ProfitPrice)
		if err != nil {
			return nil, err
		}
	} else {
		err = dbConn.QueryRow(sqlstr, gid).Scan(&g.Gid, &g.Pid, &g.Title, &g.AttributeGoodTitle, &g.Fid, &g.Fgid, &g.Sid, &g.Fbid, &g.Gcid, &g.Fcid, &g.Fpid, &g.Status, &g.StatusChangeLastTimestamp, &g.FactoryOnly, &g.PriceMode, &g.Price, &g.PlanID, &g.PlanIDStatus, &g.PlanNextID, &g.PlanNextTime, &g.PlanNextPrice, &g.PlanNextIDStatus, &g.PrepayPrice, &g.CanCod, &g.HasInvoice, &g.Subtitle, &g.Content, &g.Packinfo, &g.Weight, &g.Volume, &g.Sku, &g.ProductCode, &g.BarCode, &g.Stock, &g.FrozenStock, &g.Stockday, &g.Unit, &g.SoldNum, &g.ListPicPath, &g.ListPicPicids, &g.Created, &g.Updated, &g.PlanUpTimestamp, &g.PlanDownTimestamp, &g.SeoKeyword, &g.SeoDescription, &g.Fwid, &g.ShipID, &g.IsCheck, &g.ImageMode, &g.MarketPrice, &g.OtherImagePath, &g.BrandTpID, &g.PackTpID, &g.DelegationTpID, &g.ServiceTpID, &g.ReportTpID, &g.CustomContent, &g.Visited, &g.GoodsCommentNum, &g.CategoryGlobalPathIds, &g.AttributeValueIds, &g.HelpMap, &g.BrandID, &g.ProfitPrice)
		if err != nil {
			return nil, err
		}
	}

	return &g, nil
}

// GoodsByIsCheck retrieves a row from 'aypcddg.goods' as a Good.
//
// Generated from index 'goods_is_check_index'.
func GoodsByIsCheck(ctx context.Context, isCheck int8, key ...interface{}) ([]*Good, error) {
	var err error
	var dbConn *sql.DB

	tableName, err := GetGoodTableName(key...)
	if err != nil {
		return nil, err
	}

	// sql query
	sqlstr := `SELECT ` +
		`gid, pid, title, attribute_good_title, fid, fgid, sid, fbid, gcid, fcid, fpid, status, status_change_last_timestamp, factory_only, price_mode, price, plan_id, plan_id_status, plan_next_id, plan_next_time, plan_next_price, plan_next_id_status, prepay_price, can_cod, has_invoice, subtitle, content, packinfo, weight, volume, sku, product_code, bar_code, stock, frozen_stock, stockday, unit, sold_num, list_pic_path, list_pic_picids, created, updated, plan_up_timestamp, plan_down_timestamp, seo_keyword, seo_description, fwid, ship_id, is_check, image_mode, market_price, other_image_path, brand_tp_id, pack_tp_id, delegation_tp_id, service_tp_id, report_tp_id, custom_content, visited, goods_comment_num, category_global_path_ids, attribute_value_ids, help_map, brand_id, profit_price ` +
		`FROM ` + tableName +
		` WHERE is_check = ?`

	// run query
	utils.GetTraceLog(ctx).Debug("DB", zap.String("SQL", fmt.Sprint(sqlstr, isCheck)))

	tx, err := components.M.GetConnFromCtx(ctx)
	if err != nil {
		dbConn, err = components.M.GetSlaveConn()
		if err != nil {
			return nil, err
		}
	}
	var queryData *sql.Rows
	if tx != nil {
		queryData, err = tx.Query(sqlstr, isCheck)
		if err != nil {
			return nil, err
		}
	} else {
		queryData, err = dbConn.Query(sqlstr, isCheck)
		if err != nil {
			return nil, err
		}
	}

	defer queryData.Close()

	// load results
	res := make([]*Good, 0)
	for queryData.Next() {
		g := Good{
			_exists: true,
		}

		// scan
		err = queryData.Scan(&g.Gid, &g.Pid, &g.Title, &g.AttributeGoodTitle, &g.Fid, &g.Fgid, &g.Sid, &g.Fbid, &g.Gcid, &g.Fcid, &g.Fpid, &g.Status, &g.StatusChangeLastTimestamp, &g.FactoryOnly, &g.PriceMode, &g.Price, &g.PlanID, &g.PlanIDStatus, &g.PlanNextID, &g.PlanNextTime, &g.PlanNextPrice, &g.PlanNextIDStatus, &g.PrepayPrice, &g.CanCod, &g.HasInvoice, &g.Subtitle, &g.Content, &g.Packinfo, &g.Weight, &g.Volume, &g.Sku, &g.ProductCode, &g.BarCode, &g.Stock, &g.FrozenStock, &g.Stockday, &g.Unit, &g.SoldNum, &g.ListPicPath, &g.ListPicPicids, &g.Created, &g.Updated, &g.PlanUpTimestamp, &g.PlanDownTimestamp, &g.SeoKeyword, &g.SeoDescription, &g.Fwid, &g.ShipID, &g.IsCheck, &g.ImageMode, &g.MarketPrice, &g.OtherImagePath, &g.BrandTpID, &g.PackTpID, &g.DelegationTpID, &g.ServiceTpID, &g.ReportTpID, &g.CustomContent, &g.Visited, &g.GoodsCommentNum, &g.CategoryGlobalPathIds, &g.AttributeValueIds, &g.HelpMap, &g.BrandID, &g.ProfitPrice)
		if err != nil {
			return nil, err
		}

		res = append(res, &g)
	}

	return res, nil
}

// GoodsByPid retrieves a row from 'aypcddg.goods' as a Good.
//
// Generated from index 'goods_pid_index'.
func GoodsByPid(ctx context.Context, pid int, key ...interface{}) ([]*Good, error) {
	var err error
	var dbConn *sql.DB

	tableName, err := GetGoodTableName(key...)
	if err != nil {
		return nil, err
	}

	// sql query
	sqlstr := `SELECT ` +
		`gid, pid, title, attribute_good_title, fid, fgid, sid, fbid, gcid, fcid, fpid, status, status_change_last_timestamp, factory_only, price_mode, price, plan_id, plan_id_status, plan_next_id, plan_next_time, plan_next_price, plan_next_id_status, prepay_price, can_cod, has_invoice, subtitle, content, packinfo, weight, volume, sku, product_code, bar_code, stock, frozen_stock, stockday, unit, sold_num, list_pic_path, list_pic_picids, created, updated, plan_up_timestamp, plan_down_timestamp, seo_keyword, seo_description, fwid, ship_id, is_check, image_mode, market_price, other_image_path, brand_tp_id, pack_tp_id, delegation_tp_id, service_tp_id, report_tp_id, custom_content, visited, goods_comment_num, category_global_path_ids, attribute_value_ids, help_map, brand_id, profit_price ` +
		`FROM ` + tableName +
		` WHERE pid = ?`

	// run query
	utils.GetTraceLog(ctx).Debug("DB", zap.String("SQL", fmt.Sprint(sqlstr, pid)))

	tx, err := components.M.GetConnFromCtx(ctx)
	if err != nil {
		dbConn, err = components.M.GetSlaveConn()
		if err != nil {
			return nil, err
		}
	}
	var queryData *sql.Rows
	if tx != nil {
		queryData, err = tx.Query(sqlstr, pid)
		if err != nil {
			return nil, err
		}
	} else {
		queryData, err = dbConn.Query(sqlstr, pid)
		if err != nil {
			return nil, err
		}
	}

	defer queryData.Close()

	// load results
	res := make([]*Good, 0)
	for queryData.Next() {
		g := Good{
			_exists: true,
		}

		// scan
		err = queryData.Scan(&g.Gid, &g.Pid, &g.Title, &g.AttributeGoodTitle, &g.Fid, &g.Fgid, &g.Sid, &g.Fbid, &g.Gcid, &g.Fcid, &g.Fpid, &g.Status, &g.StatusChangeLastTimestamp, &g.FactoryOnly, &g.PriceMode, &g.Price, &g.PlanID, &g.PlanIDStatus, &g.PlanNextID, &g.PlanNextTime, &g.PlanNextPrice, &g.PlanNextIDStatus, &g.PrepayPrice, &g.CanCod, &g.HasInvoice, &g.Subtitle, &g.Content, &g.Packinfo, &g.Weight, &g.Volume, &g.Sku, &g.ProductCode, &g.BarCode, &g.Stock, &g.FrozenStock, &g.Stockday, &g.Unit, &g.SoldNum, &g.ListPicPath, &g.ListPicPicids, &g.Created, &g.Updated, &g.PlanUpTimestamp, &g.PlanDownTimestamp, &g.SeoKeyword, &g.SeoDescription, &g.Fwid, &g.ShipID, &g.IsCheck, &g.ImageMode, &g.MarketPrice, &g.OtherImagePath, &g.BrandTpID, &g.PackTpID, &g.DelegationTpID, &g.ServiceTpID, &g.ReportTpID, &g.CustomContent, &g.Visited, &g.GoodsCommentNum, &g.CategoryGlobalPathIds, &g.AttributeValueIds, &g.HelpMap, &g.BrandID, &g.ProfitPrice)
		if err != nil {
			return nil, err
		}

		res = append(res, &g)
	}

	return res, nil
}

// GoodsByStatus retrieves a row from 'aypcddg.goods' as a Good.
//
// Generated from index 'goods_status_index'.
func GoodsByStatus(ctx context.Context, status bool, key ...interface{}) ([]*Good, error) {
	var err error
	var dbConn *sql.DB

	tableName, err := GetGoodTableName(key...)
	if err != nil {
		return nil, err
	}

	// sql query
	sqlstr := `SELECT ` +
		`gid, pid, title, attribute_good_title, fid, fgid, sid, fbid, gcid, fcid, fpid, status, status_change_last_timestamp, factory_only, price_mode, price, plan_id, plan_id_status, plan_next_id, plan_next_time, plan_next_price, plan_next_id_status, prepay_price, can_cod, has_invoice, subtitle, content, packinfo, weight, volume, sku, product_code, bar_code, stock, frozen_stock, stockday, unit, sold_num, list_pic_path, list_pic_picids, created, updated, plan_up_timestamp, plan_down_timestamp, seo_keyword, seo_description, fwid, ship_id, is_check, image_mode, market_price, other_image_path, brand_tp_id, pack_tp_id, delegation_tp_id, service_tp_id, report_tp_id, custom_content, visited, goods_comment_num, category_global_path_ids, attribute_value_ids, help_map, brand_id, profit_price ` +
		`FROM ` + tableName +
		` WHERE status = ?`

	// run query
	utils.GetTraceLog(ctx).Debug("DB", zap.String("SQL", fmt.Sprint(sqlstr, status)))

	tx, err := components.M.GetConnFromCtx(ctx)
	if err != nil {
		dbConn, err = components.M.GetSlaveConn()
		if err != nil {
			return nil, err
		}
	}
	var queryData *sql.Rows
	if tx != nil {
		queryData, err = tx.Query(sqlstr, status)
		if err != nil {
			return nil, err
		}
	} else {
		queryData, err = dbConn.Query(sqlstr, status)
		if err != nil {
			return nil, err
		}
	}

	defer queryData.Close()

	// load results
	res := make([]*Good, 0)
	for queryData.Next() {
		g := Good{
			_exists: true,
		}

		// scan
		err = queryData.Scan(&g.Gid, &g.Pid, &g.Title, &g.AttributeGoodTitle, &g.Fid, &g.Fgid, &g.Sid, &g.Fbid, &g.Gcid, &g.Fcid, &g.Fpid, &g.Status, &g.StatusChangeLastTimestamp, &g.FactoryOnly, &g.PriceMode, &g.Price, &g.PlanID, &g.PlanIDStatus, &g.PlanNextID, &g.PlanNextTime, &g.PlanNextPrice, &g.PlanNextIDStatus, &g.PrepayPrice, &g.CanCod, &g.HasInvoice, &g.Subtitle, &g.Content, &g.Packinfo, &g.Weight, &g.Volume, &g.Sku, &g.ProductCode, &g.BarCode, &g.Stock, &g.FrozenStock, &g.Stockday, &g.Unit, &g.SoldNum, &g.ListPicPath, &g.ListPicPicids, &g.Created, &g.Updated, &g.PlanUpTimestamp, &g.PlanDownTimestamp, &g.SeoKeyword, &g.SeoDescription, &g.Fwid, &g.ShipID, &g.IsCheck, &g.ImageMode, &g.MarketPrice, &g.OtherImagePath, &g.BrandTpID, &g.PackTpID, &g.DelegationTpID, &g.ServiceTpID, &g.ReportTpID, &g.CustomContent, &g.Visited, &g.GoodsCommentNum, &g.CategoryGlobalPathIds, &g.AttributeValueIds, &g.HelpMap, &g.BrandID, &g.ProfitPrice)
		if err != nil {
			return nil, err
		}

		res = append(res, &g)
	}

	return res, nil
}

// GoodsByPlanUpTimestamp retrieves a row from 'aypcddg.goods' as a Good.
//
// Generated from index 'up_stock'.
func GoodsByPlanUpTimestamp(ctx context.Context, planUpTimestamp uint, key ...interface{}) ([]*Good, error) {
	var err error
	var dbConn *sql.DB

	tableName, err := GetGoodTableName(key...)
	if err != nil {
		return nil, err
	}

	// sql query
	sqlstr := `SELECT ` +
		`gid, pid, title, attribute_good_title, fid, fgid, sid, fbid, gcid, fcid, fpid, status, status_change_last_timestamp, factory_only, price_mode, price, plan_id, plan_id_status, plan_next_id, plan_next_time, plan_next_price, plan_next_id_status, prepay_price, can_cod, has_invoice, subtitle, content, packinfo, weight, volume, sku, product_code, bar_code, stock, frozen_stock, stockday, unit, sold_num, list_pic_path, list_pic_picids, created, updated, plan_up_timestamp, plan_down_timestamp, seo_keyword, seo_description, fwid, ship_id, is_check, image_mode, market_price, other_image_path, brand_tp_id, pack_tp_id, delegation_tp_id, service_tp_id, report_tp_id, custom_content, visited, goods_comment_num, category_global_path_ids, attribute_value_ids, help_map, brand_id, profit_price ` +
		`FROM ` + tableName +
		` WHERE plan_up_timestamp = ?`

	// run query
	utils.GetTraceLog(ctx).Debug("DB", zap.String("SQL", fmt.Sprint(sqlstr, planUpTimestamp)))

	tx, err := components.M.GetConnFromCtx(ctx)
	if err != nil {
		dbConn, err = components.M.GetSlaveConn()
		if err != nil {
			return nil, err
		}
	}
	var queryData *sql.Rows
	if tx != nil {
		queryData, err = tx.Query(sqlstr, planUpTimestamp)
		if err != nil {
			return nil, err
		}
	} else {
		queryData, err = dbConn.Query(sqlstr, planUpTimestamp)
		if err != nil {
			return nil, err
		}
	}

	defer queryData.Close()

	// load results
	res := make([]*Good, 0)
	for queryData.Next() {
		g := Good{
			_exists: true,
		}

		// scan
		err = queryData.Scan(&g.Gid, &g.Pid, &g.Title, &g.AttributeGoodTitle, &g.Fid, &g.Fgid, &g.Sid, &g.Fbid, &g.Gcid, &g.Fcid, &g.Fpid, &g.Status, &g.StatusChangeLastTimestamp, &g.FactoryOnly, &g.PriceMode, &g.Price, &g.PlanID, &g.PlanIDStatus, &g.PlanNextID, &g.PlanNextTime, &g.PlanNextPrice, &g.PlanNextIDStatus, &g.PrepayPrice, &g.CanCod, &g.HasInvoice, &g.Subtitle, &g.Content, &g.Packinfo, &g.Weight, &g.Volume, &g.Sku, &g.ProductCode, &g.BarCode, &g.Stock, &g.FrozenStock, &g.Stockday, &g.Unit, &g.SoldNum, &g.ListPicPath, &g.ListPicPicids, &g.Created, &g.Updated, &g.PlanUpTimestamp, &g.PlanDownTimestamp, &g.SeoKeyword, &g.SeoDescription, &g.Fwid, &g.ShipID, &g.IsCheck, &g.ImageMode, &g.MarketPrice, &g.OtherImagePath, &g.BrandTpID, &g.PackTpID, &g.DelegationTpID, &g.ServiceTpID, &g.ReportTpID, &g.CustomContent, &g.Visited, &g.GoodsCommentNum, &g.CategoryGlobalPathIds, &g.AttributeValueIds, &g.HelpMap, &g.BrandID, &g.ProfitPrice)
		if err != nil {
			return nil, err
		}

		res = append(res, &g)
	}

	return res, nil
}
